<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTT 3D Local</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Script para os ícones do Lucide (URL CORRIGIDA) -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
        }
        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* --- NOVA UI DE ÍCONES --- */
        #iconToolbar {
            position: fixed;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            background: rgba(26, 26, 26, 0.9);
            color: #f0f0f0;
            border-radius: 12px;
            padding: 12px 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1001;
        }
        
        .toolbar-icon {
            position: relative;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            color: #d4d4d8;
            transition: all 0.2s ease;
        }
        .toolbar-icon:hover {
            background-color: #3f3f46;
            color: white;
        }
        .toolbar-icon.active {
             background-color: #52525b;
             color: #a7f3d0;
        }

        /* Tooltip */
        .toolbar-icon[data-tooltip]:before {
            content: attr(data-tooltip);
            position: absolute;
            left: 52px; /* Posição à direita do ícone */
            top: 50%;
            transform: translateY(-50%);
            padding: 6px 10px;
            background: #2727a; 
            color: white;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            white-space: nowrap;
            display: none;
            z-index: 1002;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .toolbar-icon[data-tooltip]:hover:before {
            display: block;
        }
        
        /* Painel Contextual */
        #contextualPanelContainer {
            position: fixed;
            top: 50%;
            left: 68px; /* Ao lado da barra de ícones */
            transform: translateY(-50%);
            z-index: 1000;
            width: 280px;
            background: rgba(30, 30, 30, 0.9);
            color: #f0f0f0;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #panelContent h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: #a7f3d0; /* Verde menta */
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* NOVO: Sub-título para painel de iluminação */
        #panelContent h4 {
            font-size: 0.875rem;
            font-weight: 500;
            color: #d4d4d8;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 8px;
        }
        
        #panelContent button, #panelContent .file-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 10px;
            background-color: #3f3f46; /* Cinza-zinco 700 */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 8px;
            transition: background-color 0.2s;
        }
        #panelContent button:hover, #panelContent .file-label:hover {
            background-color: #52525b; /* Cinza-zinco 600 */
        }
        
        #panelContent select {
            width: 100%;
            padding: 10px;
            background-color: #3f3f46;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 8px;
        }
        
        #panelContent input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
            margin-top: 8px;
        }
        #panelContent input[type="range"] {
            width: 100%;
        }
        
        #panelContent .slider-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
        }
        #panelContent .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            color: #d4d4d8;
            margin-top: 8px;
        }
        
        #panelContent .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
        }

        .hidden {
            display: none !important;
        }

        /* CSS para Modo Imersivo */
        body.immersive-mode #iconToolbar,
        body.immersive-mode #contextualPanelContainer {
            display: none;
        }
    </style>

    <!-- Importmap: Define os módulos do Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/",
                "three/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/controls/OrbitControls.js",
                "three/controls/TransformControls": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/controls/TransformControls.js",
                "three/controls/PointerLockControls": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/controls/PointerLockControls.js",
                "three/loaders/GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/loaders/GLTFLoader.js",
                "three/postprocessing/EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/EffectComposer.js",
                "three/postprocessing/RenderPass": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/RenderPass.js",
                "three/shaders/BokehShader": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/shaders/BokehShader.js",
                "three/postprocessing/BokehPass": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/BokehPass.js",
                "three/postprocessing/OutputPass": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/OutputPass.js",
                
                "three/postprocessing/UnrealBloomPass": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/UnrealBloomPass.js",
                "three/postprocessing/ShaderPass": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/ShaderPass.js",
                "three/shaders/LuminosityHighPassShader": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/shaders/LuminosityHighPassShader.js",
                "three/shaders/CopyShader": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/shaders/CopyShader.js",
                "three/shaders/VignetteShader": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/shaders/VignetteShader.js",
                "three/shaders/ColorCorrectionShader": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/shaders/ColorCorrectionShader.js",
                
                "three/postprocessing/SMAAPass": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/SMAAPass.js",
                
                "three/postprocessing/OutlinePass": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/OutlinePass.js",
                "three/shaders/FXAAShader": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/shaders/FXAAShader.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvasContainer"></div>

    <!-- Nova Barra de Ícones -->
    <div id="iconToolbar">
        <div class="toolbar-icon" data-tooltip="Cena (Salvar/Carregar)" id="panelBtn-scene">
            <i data-lucide="save"></i>
        </div>
        <div class="toolbar-icon" data-tooltip="Tokens (Adicionar)" id="panelBtn-tokens">
            <i data-lucide="box"></i>
        </div>
        <div class="toolbar-icon" data-tooltip="Luzes" id="panelBtn-lights">
            <i data-lucide="sun"></i>
        </div>
        <div class="toolbar-icon" data-tooltip="Chão" id="panelBtn-ground">
            <i data-lucide="square"></i>
        </div>
        <!-- BOTÃO DO CÉU ATUALIZADO -->
        <div class="toolbar-icon" data-tooltip="Iluminação Global (Céu/Sol)" id="panelBtn-world">
            <i data-lucide="cloud"></i>
        </div>
        <div class="toolbar-icon" data-tooltip="Câmera (Filtros)" id="panelBtn-camera">
            <i data-lucide="camera"></i>
        </div>
        
        <div class="flex-grow"></div> <!-- Espaçador -->
        
        <div class="toolbar-icon" data-tooltip="Modo Câmera (C)" id="cameraModeBtn">
            <i data-lucide="orbit" id="cameraModeIcon"></i>
        </div>
        <div class="toolbar-icon" data-tooltip="Modo Imersivo (H)" id="immersiveModeBtn">
            <i data-lucide="minimize-2"></i>
        </div>
    </div>
    
    <!-- Novo Painel Contextual -->
    <div id="contextualPanelContainer" class="hidden">
        <div id="panelContent">
            <!-- Conteúdo será injetado aqui via JS -->
        </div>
    </div>

    <!-- Inputs de Arquivo Globais (ocultos) -->
    <input type="file" id="loadSceneInput" accept=".json" class="hidden">
    <input type="file" id="loadSkyboxInput" accept="image/png, image/jpeg" class="hidden">
    <input type="file" id="loadImageInput" accept="image/png, image/jpeg" class="hidden">
    <input type="file" id="loadModelInput" accept=".glb" class="hidden">


    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/controls/OrbitControls';
        import { TransformControls } from 'three/controls/TransformControls';
        import { PointerLockControls } from 'three/controls/PointerLockControls';
        import { GLTFLoader } from 'three/loaders/GLTFLoader';
        import { EffectComposer } from 'three/postprocessing/EffectComposer';
        import { RenderPass } from 'three/postprocessing/RenderPass';
        import { BokehPass } from 'three/postprocessing/BokehPass';
        import { OutputPass } from 'three/postprocessing/OutputPass';
        
        // NOVOS IMPORTS
        import { UnrealBloomPass } from 'three/postprocessing/UnrealBloomPass';
        import { ShaderPass } from 'three/postprocessing/ShaderPass';
        import { VignetteShader } from 'three/shaders/VignetteShader';
        import { ColorCorrectionShader } from 'three/shaders/ColorCorrectionShader';
        import { SMAAPass } from 'three/postprocessing/SMAAPass'; 
        
        // NOVO: IMPORTS DO OUTLINE
        import { OutlinePass } from 'three/postprocessing/OutlinePass';
        import { FXAAShader } from 'three/shaders/FXAAShader'; // Dependência do OutlinePass


        let scene, camera, renderer, orbitControls, transformControls;
        let groundPlane, gridHelper, ambientLight, sunLight; // gridHelper agora é global
        const canvasContainer = document.getElementById('canvasContainer');
        
        // Controles de Câmera FPS
        let pointerLockControls = null;
        let cameraMode = 'orbit'; // 'orbit', 'explore', 'cinematic'
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const clock = new THREE.Clock(); 

        // --- NOVA UI ---
        const iconToolbar = document.getElementById('iconToolbar');
        const panelContainer = document.getElementById('contextualPanelContainer');
        const panelContent = document.getElementById('panelContent');
        const panelButtons = document.querySelectorAll('.toolbar-icon[id^="panelBtn-"]');
        const cameraModeBtn = document.getElementById('cameraModeBtn');
        const cameraModeIcon = document.getElementById('cameraModeIcon');
        const immersiveModeBtn = document.getElementById('immersiveModeBtn');
        let currentOpenPanel = null;
        
        // Inputs de arquivo (agora globais)
        const loadSceneInput = document.getElementById('loadSceneInput');
        const loadSkyboxInput = document.getElementById('loadSkyboxInput');
        const loadImageInput = document.getElementById('loadImageInput');
        const loadModelInput = document.getElementById('loadModelInput');
        
        // Armazenamento de Recursos Carregados
        const loadedResources = new Map();

        let draggableObjects = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedObject = null;

        // Pós-processamento
        let composer, bokehPass, renderPass, bloomPass, vignettePass, colorCorrectionPass, smaaPass; 
        let outlinePass; // NOVO: Outline Pass

        // Lógica de Clique vs Arraste
        let clickTimer = null;
        let isDragging = false;
        const clickThreshold = 300; 
        let dragObject = null;

        let customSkyboxResourceName = null;
        
        // Variáveis de estado da UI (para recriar painéis)
        let lightSelectState = 'none';
        
        // NOVO: Variável de estado do ângulo do sol
        let sunAngle = 45; 

        window.onload = () => {
            init();
            animate();
            
            try {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                } else {
                    console.error("Lucide library not loaded by window.onload.");
                }
            } catch (err) {
                console.error("Error creating lucide icons:", err);
            }
        };

        function init() {
            // Cena
            scene = new THREE.Scene();

            // Câmera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 20, 25); 

            // Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true }); // AA Padrão (necessário)
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            canvasContainer.appendChild(renderer.domElement);
            
            // Pós-processamento
            setupPostProcessing();
            
            // Luzes
            ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
            // sunLight.position.set(20, 30, 20); // Removido, agora controlado por updateSunPosition
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            sunLight.shadow.bias = -0.0005;
            sunLight.shadow.normalBias = 0.05;
            scene.add(sunLight);
            
            loadSkybox('default'); // Isso agora também define a posição/ângulo do sol

            // Chão
            groundPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ 
                    color: 0x444444, 
                    side: THREE.DoubleSide, 
                    roughness: 0.8, 
                    metalness: 0.2
                })
            );
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.receiveShadow = true;
            groundPlane.name = "ground";
            scene.add(groundPlane);

            // Grid (agora global)
            gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0x888888);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Controles da Câmera (Órbita)
            createOrbitControls();
            
            // Controles de Transformação (Gizmo)
            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', (event) => {
                if (orbitControls) orbitControls.enabled = !event.value;
                if (selectedObject) {
                    selectedObject.userData.isGizmoDragging = event.value;
                }
            });
            transformControls.addEventListener('objectChange', () => {
                if (selectedObject) {
                    const minY = getRequiredHeightForGround(selectedObject);
                    if (selectedObject.position.y < minY && selectedObject.userData.type !== 'model_glb') {
                         selectedObject.position.y = minY;
                    } else if (selectedObject.userData.type === 'model_glb') {
                        const box = new THREE.Box3().setFromObject(selectedObject);
                        const currentBaseY = box.min.y;
                        if(currentBaseY < 0) {
                            selectedObject.position.y -= currentBaseY;
                        }
                    }
                }
            });
            transformControls.setSize(1.0);
            scene.add(transformControls);

            // Listeners de eventos
            window.addEventListener('resize', onWindowResize);
            
            canvasContainer.addEventListener('mousedown', onMouseDown, false); 
            canvasContainer.addEventListener('mouseup', onMouseUp, false); 
            canvasContainer.addEventListener('mousemove', onMouseMove, false); 
            
            window.addEventListener('keydown', onKeyDown, false); 
            window.addEventListener('keyup', onKeyUp, false);

            // --- NOVA UI ---
            panelButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const panelName = btn.id.split('-')[1];
                    
                    if (currentOpenPanel === panelName) {
                        closeContextualPanel();
                    } else {
                        openContextualPanel(panelName, btn);
                    }
                    e.stopPropagation();
                });
            });
            
            document.addEventListener('click', (e) => {
                if (!panelContainer.classList.contains('hidden') && !panelContainer.contains(e.target)) {
                    closeContextualPanel();
                }
            });

            cameraModeBtn.addEventListener('click', toggleCameraMode);
            immersiveModeBtn.addEventListener('click', toggleImmersiveMode);
            
            // Inputs de Arquivo
            loadSceneInput.addEventListener('change', loadScene);
            loadSkyboxInput.addEventListener('change', handleLoadCustomSkybox);
            loadImageInput.addEventListener('change', (e) => handleFileToken(e, 'image_sprite'));
            loadModelInput.addEventListener('change', (e) => handleFileToken(e, 'model_glb'));
        }
        
        // --- FUNÇÕES DA NOVA UI ---
        
        function closeContextualPanel() {
            panelContainer.classList.add('hidden');
            currentOpenPanel = null;
            panelButtons.forEach(b => b.classList.remove('active'));
        }
        
        function openContextualPanel(panelName, btnElement) {
            panelContainer.classList.remove('hidden');
            panelContent.innerHTML = ''; 
            currentOpenPanel = panelName;
            
            panelButtons.forEach(b => b.classList.remove('active'));
            if (btnElement) btnElement.classList.add('active');

            switch (panelName) {
                case 'scene':
                    panelContent.innerHTML = `
                        <h3>Cena</h3>
                        <label for="loadSceneInput" class="file-label">
                            <i data-lucide="upload" class="w-4 h-4"></i> Carregar Cena (.json)
                        </label>
                        <button id="saveSceneBtn">
                            <i data-lucide="save" class="w-4 h-4"></i> Salvar Cena (.json)
                        </button>`;
                    document.getElementById('saveSceneBtn').addEventListener('click', saveScene);
                    break;
                    
                case 'tokens':
                    panelContent.innerHTML = `
                        <h3>Tokens</h3>
                        <button id="addCubeBtn">
                            <i data-lucide="cube" class="w-4 h-4"></i> Adicionar Cubo
                        </button>
                        <button id="addSphereBtn">
                            <i data-lucide="circle" class="w-4 h-4"></i> Adicionar Esfera
                        </button>
                        <label for="loadImageInput" class="file-label">
                            <i data-lucide="image" class="w-4 h-4"></i> Carregar Token Imagem
                        </label>
                        <label for="loadModelInput" class="file-label">
                            <i data-lucide="box" class="w-4 h-4"></i> Carregar Modelo (.glb)
                        </label>`;
                    document.getElementById('addCubeBtn').addEventListener('click', () => addNewToken('cube'));
                    document.getElementById('addSphereBtn').addEventListener('click', () => addNewToken('sphere'));
                    break;

                case 'lights':
                    panelContent.innerHTML = `
                        <h3>Luzes Locais</h3>
                        <input type="color" id="lightColorInput" value="#ffffff">
                        <button id="addLightBtn">
                            <i data-lucide="plus" class="w-4 h-4"></i> Adicionar Luz de Ponto
                        </button>
                        <label for="lightSelect" class="slider-label">Selecionar Luz</label>
                        <select id="lightSelect">
                            <option value="none">Nenhuma</option>
                        </select>`;
                    document.getElementById('addLightBtn').addEventListener('click', () => {
                        const color = document.getElementById('lightColorInput').value;
                        addNewToken('point_light', { color: color });
                    });
                    
                    const lightSelect = document.getElementById('lightSelect');
                    lightSelect.addEventListener('change', () => {
                        const selectedId = lightSelect.value;
                        lightSelectState = selectedId; 
                        if (selectedId === 'none') {
                            setSelectedObject(null);
                        } else {
                            const lightObject = draggableObjects.find(o => o.uuid === selectedId);
                            if (lightObject) {
                                setSelectedObject(lightObject);
                            }
                        }
                    });
                    
                    updateLightSelector(); 
                    break;
                    
                // PAINEL DO CHÃO ATUALIZADO
                case 'ground':
                    const roughness = (groundPlane.material.roughness * 100).toFixed(0);
                    const metalness = (groundPlane.material.metalness * 100).toFixed(0);
                    const gridVisible = gridHelper.visible;
                    
                    panelContent.innerHTML = `
                        <h3>Propriedades do Chão</h3>
                        <div class="slider-group">
                            <label class="slider-label"><span>Rugosidade</span><span id="groundRoughnessValue">${roughness}%</span></label>
                            <input type="range" id="groundRoughnessSlider" min="0" max="100" value="${roughness}">
                        </div>
                        <div class="slider-group">
                            <label class="slider-label"><span>Metalicidade</span><span id="groundMetalnessValue">${metalness}%</span></label>
                            <input type="range" id="groundMetalnessSlider" min="0" max="100" value="${metalness}">
                        </div>
                        
                        <div class="checkbox-group" style="margin-top: 16px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 16px;">
                            <input type="checkbox" id="gridToggle" ${gridVisible ? 'checked' : ''}>
                            <label for="gridToggle">Mostrar Grid</label>
                        </div>
                        `;
                    
                    // Chama a nova função para configurar os listeners
                    setupGroundControls();
                    break;

                // CASO DO CÉU ATUALIZADO
                case 'world':
                    const sunIntensity = sunLight.intensity.toFixed(1);
                    const sunColor = '#' + sunLight.color.getHexString();
                    const ambientIntensity = ambientLight.intensity.toFixed(2);
                    const sunAngleValue = sunAngle;
                
                    panelContent.innerHTML = `
                        <h3>Iluminação Global</h3>
                        
                        <h4>Céu (Skybox)</h4>
                        <select id="skyboxSelect">
                            <option value="default">Padrão (Escuro)</option>
                            <option value="day">Dia (Parque)</option>
                            <option value="sunset">Pôr do Sol (Ponte)</option>
                            <option value="night">Noite (Via Láctea)</option>
                        </select>
                        <label for="loadSkyboxInput" class="file-label">
                            <i data-lucide="image-up" class="w-4 h-4"></i> Carregar Céu (360)
                        </label>
                        
                        <h4>Iluminação (Presets)</h4>
                        <button id="applyNightModeBtn">
                            <i data-lucide="moon" class="w-4 h-4"></i> Aplicar Iluminação Noturna
                        </button>
                        
                        <h4>Iluminação (Manual)</h4>
                        <div class="slider-group">
                            <label class="slider-label"><span>Intensidade (Sol)</span><span id="sunIntensityValue">${sunIntensity}</span></label>
                            <input type="range" id="sunIntensitySlider" min="0" max="10" value="${sunIntensity}" step="0.1">
                        </div>
                        <div class="slider-group">
                            <label class="slider-label"><span>Ângulo do Sol</span><span id="sunAngleValue">${sunAngleValue}°</span></label>
                            <input type="range" id="sunAngleSlider" min="0" max="360" value="${sunAngleValue}" step="1">
                        </div>
                        <label class="slider-label" style="margin-top: 4px;">Cor do Sol</label>
                        <input type="color" id="sunColorInput" value="${sunColor}">

                        <div class="slider-group">
                            <label class="slider-label"><span>Intensidade (Ambiente)</span><span id="ambientIntensityValue">${ambientIntensity}</span></label>
                            <input type="range" id="ambientIntensitySlider" min="0" max="2" value="${ambientIntensity}" step="0.05">
                        </div>
                        `;
                    
                    const skySelect = document.getElementById('skyboxSelect');
                    if (customSkyboxResourceName) {
                        addCustomSkyboxOption(skySelect);
                    }
                    skySelect.value = getSkyboxSelectState(); 
                    
                    skySelect.addEventListener('change', (e) => {
                        const value = e.target.value;
                        if (value === 'custom') {
                            if (customSkyboxResourceName) {
                                const dataURL = loadedResources.get(customSkyboxResourceName);
                                if (dataURL) loadSkybox('custom', dataURL);
                                else handleLoadCustomSkybox();
                            } else {
                                handleLoadCustomSkybox();
                            }
                        } else {
                            loadSkybox(value);
                        }
                        // Recarregar o painel para atualizar os sliders
                        openContextualPanel('world', btnElement);
                    });
                    
                    // NOVO: Listener para o botão de modo noturno
                    document.getElementById('applyNightModeBtn').addEventListener('click', () => {
                        applyNightLightingPreset();
                        // Recarregar o painel para mostrar os novos valores
                        openContextualPanel('world', btnElement); 
                    });
                    
                    // Listeners dos novos controles
                    const sunIntensitySlider = document.getElementById('sunIntensitySlider');
                    const sunIntensityValue = document.getElementById('sunIntensityValue');
                    sunIntensitySlider.addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        sunLight.intensity = val;
                        sunIntensityValue.textContent = val.toFixed(1);
                    });
                    
                    const sunAngleSlider = document.getElementById('sunAngleSlider');
                    const sunAngleValueEl = document.getElementById('sunAngleValue');
                    sunAngleSlider.addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        updateSunPosition(val); // Atualiza a posição
                        sunAngleValueEl.textContent = `${val.toFixed(0)}°`;
                    });

                    document.getElementById('sunColorInput').addEventListener('input', (e) => {
                        sunLight.color.set(e.target.value);
                    });
                    
                    const ambientIntensitySlider = document.getElementById('ambientIntensitySlider');
                    const ambientIntensityValue = document.getElementById('ambientIntensityValue');
                    ambientIntensitySlider.addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        ambientLight.intensity = val;
                        ambientIntensityValue.textContent = val.toFixed(2);
                    });
                    
                    break;
                    
                case 'camera':
                    const fov = camera.fov;
                    // DOF
                    const dofEnabled = bokehPass.enabled;
                    const focus = bokehPass.uniforms['focus'].value;
                    const aperture = bokehPass.uniforms['aperture'].value * 1e5;
                    // Bloom
                    const bloomEnabled = bloomPass.enabled;
                    const bloomStrength = bloomPass.strength;
                    const bloomThreshold = bloomPass.threshold;
                    // Vignette
                    const vignetteEnabled = vignettePass.enabled;
                    const vignetteDarkness = vignettePass.uniforms['darkness'].value;
                    
                    // --- CORREÇÃO DE BUG ---
                    
                    // Color Correction
                    const colorEnabled = colorCorrectionPass.enabled;
                    const saturation = (colorCorrectionPass.uniforms['mulRGB']) 
                        ? colorCorrectionPass.uniforms['mulRGB'].value.x - 1.0 
                        : 0.0;
                    const contrast = (colorCorrectionPass.uniforms['powRGB']) 
                        ? colorCorrectionPass.uniforms['powRGB'].value.x - 2.0 
                        : 0.0;
                    // --- FIM DA CORREÇÃO ---

                    panelContent.innerHTML = `
                        <h3>Câmera (Filtros)</h3>
                        <div class="slider-group">
                            <label class="slider-label"><span>Campo de Visão (FOV)</span><span id="fovValue">${fov}</span></label>
                            <input type="range" id="fovSlider" min="20" max="120" value="${fov}">
                        </div>
                        
                        <!-- DOF -->
                        <div class="checkbox-group" style="margin-top: 16px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 16px;">
                            <input type="checkbox" id="dofToggle" ${dofEnabled ? 'checked' : ''}>
                            <label for="dofToggle">Profundidade de Campo</label>
                        </div>
                        <div id="dofFocusControls" class="slider-group ${dofEnabled ? '' : 'hidden'}">
                            <label class="slider-label"><span>Distância Foco</span><span id="dofFocusValue">${focus.toFixed(1)}</span></label>
                            <input type="range" id="dofFocusSlider" min="1" max="100" value="${focus}" step="0.1">
                        </div>
                        <div id="dofApertureControls" class="slider-group ${dofEnabled ? '' : 'hidden'}">
                            <label class="slider-label"><span>Abertura (Desfoque)</span><span id="dofApertureValue">${aperture.toFixed(1)}</span></label>
                            <input type="range" id="dofApertureSlider" min="0" max="20" value="${aperture}" step="0.1">
                        </div>
                        
                        <!-- BLOOM -->
                        <div class="checkbox-group" style="margin-top: 16px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 16px;">
                            <input type="checkbox" id="bloomToggle" ${bloomEnabled ? 'checked' : ''}>
                            <label for="bloomToggle">Bloom (Brilho)</label>
                        </div>
                        <div id="bloomStrengthControls" class="slider-group ${bloomEnabled ? '' : 'hidden'}">
                            <label class="slider-label"><span>Intensidade</span><span id="bloomStrengthValue">${bloomStrength.toFixed(2)}</span></label>
                            <input type="range" id="bloomStrengthSlider" min="0" max="3" value="${bloomStrength}" step="0.01">
                        </div>
                        <div id="bloomThresholdControls" class="slider-group ${bloomEnabled ? '' : 'hidden'}">
                            <label class="slider-label"><span>Limite (Threshold)</span><span id="bloomThresholdValue">${bloomThreshold.toFixed(2)}</span></label>
                            <input type="range" id="bloomThresholdSlider" min="0" max="1" value="${bloomThreshold}" step="0.01">
                        </div>
                        
                        <!-- VIGNETTE -->
                        <div class="checkbox-group" style="margin-top: 16px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 16px;">
                            <input type="checkbox" id="vignetteToggle" ${vignetteEnabled ? 'checked' : ''}>
                            <label for="vignetteToggle">Vinheta</label>
                        </div>
                        <div id="vignetteControls" class="slider-group ${vignetteEnabled ? '' : 'hidden'}">
                            <label class="slider-label"><span>Escuridão</span><span id="vignetteDarknessValue">${vignetteDarkness.toFixed(1)}</span></label>
                            <input type="range" id="vignetteDarknessSlider" min="0" max="2" value="${vignetteDarkness}" step="0.1">
                        </div>
                        
                        <!-- COLOR CORRECTION -->
                        <div class="checkbox-group" style="margin-top: 16px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 16px;">
                            <input type="checkbox" id="colorToggle" ${colorEnabled ? 'checked' : ''}>
                            <label for="colorToggle">Correção de Cor</label>
                        </div>
                        <div id="colorSaturationControls" class="slider-group ${colorEnabled ? '' : 'hidden'}">
                            <label class="slider-label"><span>Saturação</span><span id="saturationValue">${saturation.toFixed(1)}</span></label>
                            <input type="range" id="saturationSlider" min="-1" max="1" value="${saturation}" step="0.1">
                        </div>
                        <div id="colorContrastControls" class="slider-group ${colorEnabled ? '' : 'hidden'}">
                            <label class="slider-label"><span>Contraste</span><span id="contrastValue">${contrast.toFixed(1)}</span></label>
                            <input type="range" id="contrastSlider" min="-1" max="1" value="${contrast}" step="0.1">
                        </div>
                        `;
                    
                    setupCameraControls();
                    break;
            }
            
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            } else {
                console.warn('Lucide not defined when opening panel.');
            }
        }
        
        // --- NOVA FUNÇÃO PARA CONTROLES DO CHÃO ---
        function setupGroundControls() {
            const grSlider = document.getElementById('groundRoughnessSlider');
            const grValue = document.getElementById('groundRoughnessValue');
            const gmSlider = document.getElementById('groundMetalnessSlider');
            const gmValue = document.getElementById('groundMetalnessValue');
            const gridToggle = document.getElementById('gridToggle');
            
            if (grSlider) {
                grSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value) / 100;
                    groundPlane.material.roughness = value;
                    grValue.textContent = `${e.target.value}%`;
                });
            }
            
            if (gmSlider) {
                gmSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value) / 100;
                    groundPlane.material.metalness = value;
                    gmValue.textContent = `${e.target.value}%`;
                });
            }
            
            if (gridToggle) {
                gridToggle.addEventListener('change', (e) => {
                    gridHelper.visible = e.target.checked;
                });
            }
        }
        
        
        // --- FUNÇÕES DE CONTROLES DE CÂMERA ---
        function createOrbitControls() {
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.maxPolarAngle = Math.PI / 2.1;
        }
        
        function createPointerLockControls() {
            pointerLockControls = new PointerLockControls(camera, renderer.domElement);
            scene.add(pointerLockControls.getObject());
            
            pointerLockControls.addEventListener('lock', () => {
                if (!document.body.classList.contains('immersive-mode')) {
                    toggleImmersiveMode();
                }
            });
        }
        
        function toggleCameraMode() {
            if (cameraMode === 'orbit') {
                // De ÓRBITA para EXPLORAR
                cameraMode = 'explore';
                cameraModeIcon.setAttribute('data-lucide', 'move-3d');
                cameraModeBtn.setAttribute('data-tooltip', 'Modo Explorar (C)');
                
                if (orbitControls) {
                    orbitControls.dispose();
                    orbitControls = null;
                }
                
                createPointerLockControls();
                camera.position.set(0, 1.8, 10);
                pointerLockControls.getObject().position.copy(camera.position);
                transformControls.enabled = false; 
                
                camera.fov = 60; // FOV Padrão
                camera.updateProjectionMatrix();

            } else if (cameraMode === 'explore') {
                // De EXPLORAR para CINEMÁTICO
                cameraMode = 'cinematic';
                cameraModeIcon.setAttribute('data-lucide', 'video');
                cameraModeBtn.setAttribute('data-tooltip', 'Modo Cinemático (C)');
                
                // Não precisa recriar o PointerLockControls, só ajustar o FOV
                camera.fov = 45; // FOV Cinematográfico
                camera.updateProjectionMatrix();

            } else { // cameraMode === 'cinematic'
                // De CINEMÁTICO para ÓRBITA
                cameraMode = 'orbit';
                cameraModeIcon.setAttribute('data-lucide', 'orbit');
                cameraModeBtn.setAttribute('data-tooltip', 'Modo Orbitar (C)');
                
                if (pointerLockControls) {
                    scene.remove(pointerLockControls.getObject());
                    pointerLockControls.dispose();
                    pointerLockControls = null;
                }
                
                createOrbitControls();
                camera.position.set(15, 20, 25);
                orbitControls.target.set(0, 0, 0); 
                transformControls.enabled = true; 
                
                camera.fov = 60; // FOV Padrão
                camera.updateProjectionMatrix();
            }
            
            if (typeof lucide !== 'undefined') {
                lucide.createIcons(); // Atualiza o ícone
            } else {
                 console.warn('Lucide not defined when toggling camera.');
            }
        }
        
        function toggleImmersiveMode() {
            document.body.classList.toggle('immersive-mode');
            if (document.body.classList.contains('immersive-mode')) {
                setSelectedObject(null);
                closeContextualPanel();
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (cameraMode === 'orbit' && orbitControls) {
                orbitControls.update();
            } else if ((cameraMode === 'explore' || cameraMode === 'cinematic') && pointerLockControls) {
                
                // Damping (amortecimento) menor para modo cinematic
                const damping = (cameraMode === 'cinematic') ? 2.0 : 10.0;
                
                velocity.x -= velocity.x * damping * delta;
                velocity.z -= velocity.z * damping * delta;
                velocity.y -= velocity.y * damping * delta; 

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.y = Number(moveUp) - Number(moveDown); // Espaço = 1, Shift = -1
                direction.normalize(); 

                // Velocidade menor para modo cinematic
                const speed = (cameraMode === 'cinematic') ? 25.0 : 40.0;
                
                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
                
                if (moveUp || moveDown) velocity.y += direction.y * speed * delta; 

                pointerLockControls.moveRight(-velocity.x * delta);
                pointerLockControls.moveForward(-velocity.z * delta);
                pointerLockControls.getObject().position.y += (velocity.y * delta); // Sobe/Desce

                if (pointerLockControls.getObject().position.y < 0.5) {
                    pointerLockControls.getObject().position.y = 0.5;
                    velocity.y = 0;
                }
            }

            // Rotação horizontal dos sprites
            const cameraPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraPosition);

            for (const object of draggableObjects) {
                if (object.userData.type === 'image_sprite') {
                    cameraPosition.y = object.position.y;
                    object.lookAt(cameraPosition);
                }
            }
            
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // NOVO: Atualiza a resolução do OutlinePass
            if (outlinePass) {
                outlinePass.resolution.set(window.innerWidth, window.innerHeight);
            }
        }
        
        // NOVO: Função helper para atualizar a posição do sol
        function updateSunPosition(angle) {
            if (angle !== undefined) {
                sunAngle = parseFloat(angle);
            }
            
            const rad = THREE.MathUtils.degToRad(sunAngle);
            const distance = 30; // Distância horizontal da origem
            const height = 30;   // Altura do sol
            
            const x = distance * Math.sin(rad);
            const z = distance * Math.cos(rad);
            
            sunLight.position.set(x, height, z);
        }
        
        // NOVO: Função helper para aplicar preset de noite
        function applyNightLightingPreset() {
            if (ambientLight) ambientLight.intensity = 0.05;
            if (sunLight) {
                sunLight.intensity = 0.5;
                sunLight.color.set(0xaaaaff); // Azulado (lua)
            }
            updateSunPosition(90); // Lua a pino
        }

        // --- Função para Carregar Skybox e Iluminação ---
        function loadSkybox(name, customDataURL = null) {
            
            if (name === 'custom' && customDataURL) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(customDataURL, (texture) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    texture.encoding = THREE.sRGBEncoding;
                    scene.background = texture;
                    scene.environment = texture;
                    
                    // Aplica iluminação padrão para customizado (pode ser ajustado)
                    if (ambientLight) ambientLight.intensity = 0.2;
                    if (sunLight) {
                        sunLight.intensity = 3.0;
                        sunLight.color.set(0xffffff);
                    }
                    updateSunPosition(45); // Posição padrão para customizado
                });
                return;
            }

            const cubeTextureLoader = new THREE.CubeTextureLoader();
            let path, format, urls;
            
            switch(name) {
                case 'day':
                    path = 'https://threejs.org/examples/textures/cube/Park2/';
                    format = '.jpg';
                    urls = [
                        path + 'px' + format, path + 'nx' + format,
                        path + 'py' + format, path + 'ny' + format,
                        path + 'pz' + format, path + 'nz' + format
                    ];
                    break;
                case 'sunset':
                    path = 'https://threejs.org/examples/textures/cube/Bridge2/';
                    format = '.jpg';
                    urls = [
                        path + 'px' + format, path + 'nx' + format,
                        path + 'py' + format, path + 'ny' + format,
                        path + 'pz' + format, path + 'nz' + format
                    ];
                    break;
                case 'night':
                    path = 'https://threejs.org/examples/textures/cube/MilkyWay/';
                    format = '.jpg';
                    urls = [
                        path + 'px' + format, path + 'nx' + format,
                        path + 'py' + format, path + 'ny' + format,
                        path + 'pz' + format, path + 'nz' + format
                    ];
                    break;
                case 'default':
                default:
                    urls = [
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+',
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+',
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+',
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+',
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+',
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+'
                    ];
                    break;
            }

            const texture = cubeTextureLoader.load(urls, () => {
                texture.encoding = THREE.sRGBEncoding; 
                scene.background = texture;
                scene.environment = texture;
            });

            // Ajusta as luzes manuais para complementar o skybox
            switch(name) {
                case 'day':
                    if (ambientLight) ambientLight.intensity = 0.2;
                    if (sunLight) {
                        sunLight.intensity = 3.0;
                        sunLight.color.set(0xffffff);
                    }
                    updateSunPosition(45);
                    break;
                case 'sunset':
                    if (ambientLight) ambientLight.intensity = 0.1;
                    if (sunLight) {
                        sunLight.intensity = 2.5;
                        sunLight.color.set(0xffaa88);
                    }
                    updateSunPosition(135); // Sol de lado
                    break;
                case 'night':
                    // USA O NOVO PRESET HELPER
                    applyNightLightingPreset(); 
                    break;
                case 'default':
                default:
                    if (ambientLight) ambientLight.intensity = 0.3;
                    if (sunLight) {
                        sunLight.intensity = 2.0;
                        sunLight.color.set(0xffffff);
                    }
                    updateSunPosition(45); // Posição padrão
                    break;
            }
        }

        // --- Funções de Câmera Cinematográfica ---
        
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Bloom
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.4, 0.85);
            bloomPass.threshold = 0.85; 
            bloomPass.strength = 0.5; 
            bloomPass.radius = 0.4; 
            bloomPass.enabled = false;
            composer.addPass(bloomPass);

            // DOF
            bokehPass = new BokehPass(scene, camera, {
                focus: 20.0,
                aperture: 5.0,
                maxblur: 0.005,
                width: window.innerWidth,
                height: window.innerHeight
            });
            bokehPass.enabled = false;
            composer.addPass(bokehPass);
            
            // Color Correction
            colorCorrectionPass = new ShaderPass(ColorCorrectionShader);
            colorCorrectionPass.uniforms['powRGB'].value = new THREE.Vector3(2.0, 2.0, 2.0); // Contrast (Base 2.0)
            colorCorrectionPass.uniforms['mulRGB'].value = new THREE.Vector3(1.0, 1.0, 1.0); // Saturation (Base 1.0)
            colorCorrectionPass.enabled = false;
            composer.addPass(colorCorrectionPass);
            
            // Vignette
            vignettePass = new ShaderPass(VignetteShader);
            vignettePass.uniforms['offset'].value = 1.0;
            vignettePass.uniforms['darkness'].value = 1.1;
            vignettePass.enabled = false;
            composer.addPass(vignettePass);

            // NOVO: OutlinePass (para o "rim light")
            outlinePass = new OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );
            outlinePass.edgeStrength = 4.0; // Força do contorno
            outlinePass.edgeGlow = 0.5; // Um leve brilho
            outlinePass.edgeThickness = 1.0; // Espessura
            outlinePass.visibleEdgeColor.set('#a7f3d0'); // Cor da UI (verde menta)
            outlinePass.hiddenEdgeColor.set('#a7f3d0'); // Mesmo se estiver atrás de algo
            composer.addPass(outlinePass);

            // NOVO: SMAAPass (Anti-Aliasing)
            // Deve ser um dos últimos passes, antes do OutputPass
            smaaPass = new SMAAPass( window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio() );
            composer.addPass(smaaPass);

            // OutputPass (SEMPRE O ÚLTIMO)
            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        function setupCameraControls() {
            // FOV
            const fovSlider = document.getElementById('fovSlider');
            const fovValue = document.getElementById('fovValue');
            fovSlider.addEventListener('input', (e) => {
                camera.fov = parseFloat(e.target.value);
                camera.updateProjectionMatrix();
                fovValue.textContent = e.target.value;
            });
            
            // DOF
            const dofToggle = document.getElementById('dofToggle');
            const dofFocusSlider = document.getElementById('dofFocusSlider');
            const dofFocusValue = document.getElementById('dofFocusValue');
            const dofApertureSlider = document.getElementById('dofApertureSlider');
            const dofApertureValue = document.getElementById('dofApertureValue');
            const dofFocusControls = document.getElementById('dofFocusControls');
            const dofApertureControls = document.getElementById('dofApertureControls');
            
            dofToggle.addEventListener('change', (e) => {
                bokehPass.enabled = e.target.checked;
                dofFocusControls.classList.toggle('hidden', !e.target.checked);
                dofApertureControls.classList.toggle('hidden', !e.target.checked);
            });
            dofFocusSlider.addEventListener('input', (e) => {
                bokehPass.uniforms['focus'].value = parseFloat(e.target.value);
                dofFocusValue.textContent = parseFloat(e.target.value).toFixed(1);
            });
            dofApertureSlider.addEventListener('input', (e) => {
                bokehPass.uniforms['aperture'].value = parseFloat(e.target.value) * 1e-5;
                dofApertureValue.textContent = parseFloat(e.target.value).toFixed(1);
            });

            // Bloom
            const bloomToggle = document.getElementById('bloomToggle');
            const bloomStrengthSlider = document.getElementById('bloomStrengthSlider');
            const bloomStrengthValue = document.getElementById('bloomStrengthValue');
            const bloomThresholdSlider = document.getElementById('bloomThresholdSlider');
            const bloomThresholdValue = document.getElementById('bloomThresholdValue');
            const bloomStrengthControls = document.getElementById('bloomStrengthControls');
            const bloomThresholdControls = document.getElementById('bloomThresholdControls');
            
            bloomToggle.addEventListener('change', (e) => {
                bloomPass.enabled = e.target.checked;
                bloomStrengthControls.classList.toggle('hidden', !e.target.checked);
                bloomThresholdControls.classList.toggle('hidden', !e.target.checked);
            });
            bloomStrengthSlider.addEventListener('input', (e) => {
                bloomPass.strength = parseFloat(e.target.value);
                bloomStrengthValue.textContent = parseFloat(e.target.value).toFixed(2);
            });
             bloomThresholdSlider.addEventListener('input', (e) => {
                bloomPass.threshold = parseFloat(e.target.value);
                bloomThresholdValue.textContent = parseFloat(e.target.value).toFixed(2);
            });
            
            // Vignette
            const vignetteToggle = document.getElementById('vignetteToggle');
            const vignetteDarknessSlider = document.getElementById('vignetteDarknessSlider');
            const vignetteDarknessValue = document.getElementById('vignetteDarknessValue');
            const vignetteControls = document.getElementById('vignetteControls');
            
            vignetteToggle.addEventListener('change', (e) => {
                vignettePass.enabled = e.target.checked;
                vignetteControls.classList.toggle('hidden', !e.target.checked);
            });
            vignetteDarknessSlider.addEventListener('input', (e) => {
                vignettePass.uniforms['darkness'].value = parseFloat(e.target.value);
                vignetteDarknessValue.textContent = parseFloat(e.target.value).toFixed(1);
            });
            
            // Color Correction
            const colorToggle = document.getElementById('colorToggle');
            const saturationSlider = document.getElementById('saturationSlider');
            const saturationValue = document.getElementById('saturationValue');
            const contrastSlider = document.getElementById('contrastSlider');
            const contrastValue = document.getElementById('contrastValue');
            const colorSaturationControls = document.getElementById('colorSaturationControls');
            const colorContrastControls = document.getElementById('colorContrastControls');

            colorToggle.addEventListener('change', (e) => {
                colorCorrectionPass.enabled = e.target.checked;
                colorSaturationControls.classList.toggle('hidden', !e.target.checked);
                colorContrastControls.classList.toggle('hidden', !e.target.checked);
            });
            saturationSlider.addEventListener('input', (e) => {
                const sat = 1.0 + parseFloat(e.target.value); // Base é 1.0
                colorCorrectionPass.uniforms['mulRGB'].value.set(sat, sat, sat);
                saturationValue.textContent = parseFloat(e.target.value).toFixed(1);
            });
            contrastSlider.addEventListener('input', (e) => {
                const con = 2.0 + parseFloat(e.target.value); // Base é 2.0
                colorCorrectionPass.uniforms['powRGB'].value.set(con, con, con);
                contrastValue.textContent = parseFloat(e.target.value).toFixed(1);
            });
        }
        
        // --- Funções de Salvar/Carregar Cena ---
        
        async function saveScene() {
            const sceneData = {
                tokens: [],
                resources: Array.from(loadedResources.entries()),
                skybox: {
                    name: getSkyboxSelectState(),
                    resourceName: (getSkyboxSelectState() === 'custom') ? customSkyboxResourceName : null
                },
                groundMaterial: {
                    roughness: groundPlane.material.roughness,
                    metalness: groundPlane.material.metalness
                },
                // NOVO: Salva o estado do grid
                grid: {
                    visible: gridHelper.visible
                },
                lighting: {
                    sunIntensity: sunLight.intensity,
                    sunColor: sunLight.color.getHexString(),
                    ambientIntensity: ambientLight.intensity,
                    sunAngle: sunAngle
                }
            };
            
            draggableObjects.forEach(obj => {
                const data = {
                    type: obj.userData.type,
                    position: obj.position.clone(),
                    scale: obj.scale.clone(),
                    rotation: obj.rotation.clone(),
                };
                
                if (obj.userData.type === 'point_light') {
                    data.color = obj.userData.light.color.getHex();
                    data.intensity = obj.userData.light.intensity;
                    data.name = obj.userData.name; 
                } else if (obj.userData.type === 'image_sprite' || obj.userData.type === 'model_glb') {
                    data.resourceName = obj.userData.resourceName;
                }
                
                sceneData.tokens.push(data);
            });
            
            const jsonString = JSON.stringify(sceneData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'vtt-scene.json';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function loadScene(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const sceneData = JSON.parse(e.target.result);
                    
                    clearScene();
                    
                    removeCustomSkyboxOption();
                    
                    if (sceneData.resources) {
                        for (const [name, dataURL] of sceneData.resources) {
                            loadedResources.set(name, dataURL);
                        }
                    }
                    
                    if (sceneData.tokens) {
                        for (const data of sceneData.tokens) {
                            await addNewToken(data.type, data);
                        }
                    }
                    
                    updateLightSelector();
                    
                    // NOVO: Carrega o estado da iluminação
                    if (sceneData.lighting) {
                        sunLight.intensity = sceneData.lighting.sunIntensity;
                        sunLight.color.set('#' + sceneData.lighting.sunColor);
                        ambientLight.intensity = sceneData.lighting.ambientIntensity;
                        updateSunPosition(sceneData.lighting.sunAngle); // Isso define o sunAngle global
                    }
                    
                    if (sceneData.skybox) {
                        const skyboxName = sceneData.skybox.name || 'default';
                        if (skyboxName === 'custom' && sceneData.skybox.resourceName) {
                            customSkyboxResourceName = sceneData.skybox.resourceName;
                            let dataURL = loadedResources.get(customSkyboxResourceName);
                            if (!dataURL) {
                                try {
                                    dataURL = await requestResourceFile(
                                         `Por favor, selecione o arquivo do Céu Customizado: ${customSkyboxResourceName}`,
                                         'image/*',
                                         500 * 1024 * 1024 
                                    );
                                    loadedResources.set(customSkyboxResourceName, dataURL);
                                } catch (err) {
                                    alert(err.message);
                                    loadSkybox('default'); // Carrega o padrão se o usuário cancelar
                                }
                            }
                            if (dataURL) loadSkybox('custom', dataURL); // Só carrega se tiver o dataURL
                        } else {
                            loadSkybox(skyboxName);
                        }
                    } else {
                        loadSkybox('default');
                    }
                    
                    if (sceneData.groundMaterial) {
                        groundPlane.material.roughness = sceneData.groundMaterial.roughness;
                        groundPlane.material.metalness = sceneData.groundMaterial.metalness;
                    } else {
                        groundPlane.material.roughness = 0.8;
                        groundPlane.material.metalness = 0.2;
                    }
                    
                    // NOVO: Carrega o estado do grid
                    gridHelper.visible = sceneData.grid?.visible ?? true;
                    
                    closeContextualPanel();
                    
                } catch (err) {
                    console.error("Erro ao carregar a cena:", err);
                    alert("Erro: Não foi possível ler o arquivo de cena.");
                }
            };
            reader.readAsText(file);
        }
        
        function clearScene() {
            setSelectedObject(null); 
            
            while (draggableObjects.length > 0) {
                const obj = draggableObjects.pop();
                
                if (obj.userData.light) {
                    scene.remove(obj.userData.light);
                }
                
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (obj.material.map) obj.material.map.dispose();
                    obj.material.dispose();
                }
                
                scene.remove(obj);
            }
            
            // Reseta o estado
            gridHelper.visible = true;
            
            updateLightSelector(); 
        }

        // --- Funções de Tokens e Objetos ---
        
        async function addNewToken(type, data = {}) {
            let mesh;
            const position = data.position ? new THREE.Vector3(data.position.x, data.position.y, data.position.z) : getSpawnPosition();
            const scale = data.scale ? new THREE.Vector3(data.scale.x, data.scale.y, data.scale.z) : new THREE.Vector3(1, 1, 1);
            const rotation = data.rotation ? new THREE.Euler(data.rotation._x, data.rotation._y, data.rotation._z) : new THREE.Euler(0, 0, 0);

            let resourceDataURL = null;
            
            if (data.resourceName) {
                resourceDataURL = loadedResources.get(data.resourceName);
                if (!resourceDataURL) {
                     alert(`Recurso "${data.resourceName}" não encontrado. Por favor, recarregue o arquivo.`);
                     try {
                         const accept = data.type === 'image_sprite' ? 'image/*' : '.glb';
                         resourceDataURL = await requestResourceFile(
                             `Por favor, selecione o arquivo para: ${data.resourceName}`,
                             accept,
                             500 * 1024 * 1024 
                         );
                         loadedResources.set(data.resourceName, dataURL);
                     } catch(err) {
                         alert(err.message);
                         return;
                     }
                }
            } 

            if (type === 'image_sprite') {
                mesh = await createTokenMesh(type, resourceDataURL);
                if (mesh.material.map && mesh.material.map.image) {
                     mesh.userData.aspectRatio = (mesh.material.map.image.height / mesh.material.map.image.width) || 1;
                } else {
                    mesh.userData.aspectRatio = 1;
                }
            } else if (type === 'model_glb') {
                mesh = await createTokenMesh(type, resourceDataURL);
            } else {
                mesh = await createTokenMesh(type, data); // Cubo, Esfera, Luz
            }

            mesh.position.copy(position);
            mesh.scale.copy(scale);
            mesh.rotation.copy(rotation);
            
            scene.add(mesh);
            
            if (!data.position) {
                if (type === 'point_light') {
                    mesh.position.y = 3;
                } else {
                    mesh.position.y = getRequiredHeightForGround(mesh);
                }
            }

            mesh.userData.type = type;
            mesh.userData.resourceName = data.resourceName || null;
            mesh.userData.isDragging = false;
            mesh.userData.isGizmoDragging = false;
            
            if (type === 'point_light') {
                if (!data.name) {
                    const lightCount = draggableObjects.filter(o => o.userData.type === 'point_light').length + 1;
                    mesh.userData.name = `Luz ${lightCount}`;
                } else {
                    mesh.userData.name = data.name;
                }
            }
            
            if (type !== 'point_light') {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
            }

            draggableObjects.push(mesh);
            
            if (type === 'point_light') {
                updateLightSelector(); 
            }
            
            return mesh;
        }
        
        function getObjectBaseHeight(object, getBase = false) {
            if (!object) return 0;
            
            if (object.userData.type === 'image_sprite') {
                return getBase ? 0 : object.position.y + object.scale.y / 2;
            } 
            
            if (object.userData.type === 'point_light') {
                return getBase ? object.position.y : object.position.y;
            }
            
            const box = new THREE.Box3().setFromObject(object);

            if (object.userData.type === 'model_glb') {
                return getBase ? box.min.y : box.max.y;
            }
            
            return getBase ? box.min.y : box.max.y;
        }

        function getRequiredHeightForGround(object) {
            if (!object) return 0;

            if (object.userData.type === 'image_sprite') {
                return object.scale.y / 2;
            }

            if (object.userData.type === 'model_glb') {
                const box = new THREE.Box3().setFromObject(object);
                const height = box.max.y - box.min.y;
                return height / 2;
            }

            if (object.userData.type === 'cube') {
                return object.scale.y / 2;
            }
            
            if (object.userData.type === 'sphere') {
                return object.scale.y / 2;
            }

            return 0; 
        }


        function createTokenMesh(type, data) {
            return new Promise((resolve, reject) => {
                let mesh;
                if (type === 'image_sprite') {
                    if (!data) return reject(new Error('Dados da imagem não fornecidos para o sprite.'));
                    const texture = new THREE.TextureLoader().load(data, (tex) => {
                        const aspectRatio = tex.image.height / tex.image.width;
                        mesh.userData.aspectRatio = aspectRatio;
                        if (mesh.scale.x === 1 && mesh.scale.y === 1) {
                             mesh.scale.set(2, 2 * aspectRatio, 1);
                        }
                        resolve(mesh);
                    }, undefined, (err) => reject(new Error('Falha ao carregar a textura da imagem: ' + err.message)));
                    
                    texture.encoding = THREE.sRGBEncoding;
                    const material = new THREE.MeshStandardMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide,
                        alphaTest: 0.1,
                        roughness: 0.8,
                        metalness: 0.1
                    });
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    mesh = new THREE.Mesh(geometry, material);

                } else if (type === 'model_glb') {
                    if (!data) return reject(new Error('Dados do modelo não fornecidos para o GLB.'));
                    const loader = new GLTFLoader();
                    loader.load(data, (gltf) => {
                        mesh = gltf.scene;
                        const box = new THREE.Box3().setFromObject(mesh);
                        const center = box.getCenter(new THREE.Vector3());
                        mesh.position.sub(center); 
                        
                        if (mesh.scale.x === 1 && mesh.scale.y === 1) {
                            const size = box.getSize(new THREE.Vector3());
                            const maxDim = Math.max(size.x, size.y, size.z);
                            const scale = 2 / maxDim;
                            mesh.scale.set(scale, scale, scale);
                        }
                        resolve(mesh);
                    }, undefined, (err) => reject(new Error('Falha ao carregar o modelo GLB: ' + err.message)));

                } else if (type === 'point_light') {
                    const lightColor = data.color ? data.color : 0xffffff;
                    const intensity = data.intensity ? data.intensity : 20.0;
                    
                    const pointLight = new THREE.PointLight(lightColor, intensity, 20);
                    pointLight.castShadow = true;
                    pointLight.shadow.bias = -0.001;
                    pointLight.shadow.normalBias = 0.05;
                    
                    const gizmoMaterial = new THREE.MeshBasicMaterial({ color: lightColor });
                    gizmoMaterial.transparent = true;
                    gizmoMaterial.opacity = 0;
                    
                    const gizmoGeometry = new THREE.SphereGeometry(0.1, 8, 4); 
                    mesh = new THREE.Mesh(gizmoGeometry, gizmoMaterial); 
                    
                    mesh.add(pointLight);
                    mesh.userData.light = pointLight;
                    resolve(mesh);
                } else {
                    const geometry = (type === 'cube') ? new THREE.BoxGeometry(1, 1, 1) : new THREE.SphereGeometry(0.5, 32, 16);
                    const material = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5, metalness: 0.1 });
                    mesh = new THREE.Mesh(geometry, material);
                    resolve(mesh);
                }
            });
        }
        
        function deleteSelectedObject() {
            if (!selectedObject) return;
            
            const objectToDelete = selectedObject;
            const wasLight = objectToDelete.userData.type === 'point_light';
            
            setSelectedObject(null);
            
            scene.remove(objectToDelete);
            
            if (objectToDelete.userData.light) {
                // A luz é filha, será removida junto
            }

            if (objectToDelete.geometry) objectToDelete.geometry.dispose();
            if (objectToDelete.material) {
                if (objectToDelete.material.map) objectToDelete.material.map.dispose();
                objectToDelete.material.dispose();
            }
            objectToDelete.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                }
            });

            const index = draggableObjects.indexOf(objectToDelete);
            if (index > -1) {
                draggableObjects.splice(index, 1);
            }
            
            if (wasLight) {
                updateLightSelector(); 
            }
        }

        
        function getIntersectedObject(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const visibleObjects = draggableObjects.filter(o => o.userData.type !== 'point_light');
            const intersects = raycaster.intersectObjects([...visibleObjects, groundPlane], true); 
            
            const objectIntersect = intersects.find(intersect => intersect.object.name !== "ground");
            
            if (objectIntersect) return objectIntersect;

            return intersects.find(intersect => intersect.object.name === "ground") || null;
        }
        
        function getSpawnPosition() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const pos = raycaster.ray.at(15, new THREE.Vector3());
            pos.y = 0; 
            return pos;
        }
        
        // --- Funções de Leitura de Arquivo ---
        
        async function handleFileToken(event, type) {
            const file = event.target.files[0];
            if (!file) return;

            const maxSize = 500 * 1024 * 1024; // 500MB
            if (file.size > maxSize) {
                alert(`Erro: O ficheiro é muito grande (${(file.size / 1024 / 1024).toFixed(1)}MB). O limite é 500MB.`);
                event.target.value = null; 
                return;
            }

            try {
                const dataURL = await fileToDataURL(file);
                const resourceName = `${type}_${file.name}_${Date.now()}`;
                loadedResources.set(resourceName, dataURL);
                
                await addNewToken(type, { resourceName: resourceName });
            } catch (err) {
                alert("Erro ao ler o ficheiro: " + err.message);
            }
            
            event.target.value = null; 
        }
        
        async function handleLoadCustomSkybox(event) {
            let file;
            if(event && event.target.files) {
                file = event.target.files[0];
            } else {
                try {
                     const dataURL = await requestResourceFile(
                        "Por favor, selecione seu arquivo de céu customizado (360).",
                        'image/*',
                        500 * 1024 * 1024 
                    );
                    const resourceName = `skybox_custom_${Date.now()}`;
                    loadedResources.set(resourceName, dataURL);
                    customSkyboxResourceName = resourceName;
                    
                    const skySelect = document.getElementById('skyboxSelect');
                    if (skySelect) { 
                        addCustomSkyboxOption(skySelect);
                        skySelect.value = 'custom';
                    }
                    
                    loadSkybox('custom', dataURL);
                    return;

                } catch (err) {
                    alert(err.message);
                    const skySelect = document.getElementById('skyboxSelect');
                    if (skySelect) skySelect.value = 'default'; 
                    return;
                }
            }

            if (!file) return;

            const maxSize = 500 * 1024 * 1024; // 500MB
            if (file.size > maxSize) {
                alert(`Erro: O ficheiro é muito grande (${(file.size / 1024 / 1024).toFixed(1)}MB). O limite é 500MB.`);
                if (event) event.target.value = null;
                return;
            }

            try {
                const dataURL = await fileToDataURL(file);
                const resourceName = `skybox_${file.name}_${Date.now()}`;
                
                if (customSkyboxResourceName) {
                    loadedResources.delete(customSkyboxResourceName);
                }
                
                loadedResources.set(resourceName, dataURL);
                customSkyboxResourceName = resourceName;
                
                const skySelect = document.getElementById('skyboxSelect');
                if (skySelect) {
                    addCustomSkyboxOption(skySelect);
                    skySelect.value = 'custom';
                }
                
                loadSkybox('custom', dataURL); 
            } catch (err) {
                alert("Erro ao ler o ficheiro: " + err.message);
            }
            
            if (event) event.target.value = null;
        }

        function addCustomSkyboxOption(selectElement) {
            if (!selectElement) return;
            let option = selectElement.querySelector('option[value="custom"]');
            if (!option) {
                option = document.createElement('option');
                option.value = 'custom';
                option.textContent = 'Customizado';
                selectElement.appendChild(option);
            }
        }
        
        function removeCustomSkyboxOption() {
             const skySelect = document.getElementById('skyboxSelect'); 
            if (skySelect) {
                let option = skySelect.querySelector('option[value="custom"]');
                if (option) {
                    option.remove();
                }
            }
            customSkyboxResourceName = null;
        }
        
        function getSkyboxSelectState() {
            const skySelect = document.getElementById('skyboxSelect');
            if(skySelect) return skySelect.value;
            return customSkyboxResourceName ? 'custom' : 'default'; 
        }

        function fileToDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        }
        
        function requestResourceFile(promptMessage, acceptType, maxSize) {
            return new Promise((resolve, reject) => {
                alert(promptMessage);
                
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = acceptType;
                
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        reject(new Error("Nenhum ficheiro selecionado."));
                        return;
                    }
                    if (file.size > maxSize) {
                        reject(new Error(`Erro: O ficheiro é muito grande (${(file.size / 1024 / 1024).toFixed(1)}MB). O limite é ${(maxSize / 1024 / 1024).toFixed(0)}MB.`));
                        return;
                    }
                    try {
                        const dataURL = await fileToDataURL(file);
                        resolve(dataURL);
                    } catch(err) {
                        reject(err);
                    }
                };
                
                window.addEventListener('focus', () => {
                     setTimeout(() => {
                        if (!input.files || input.files.length === 0) {
                           // reject(new Error("Seleção de arquivo cancelada."));
                        }
                    }, 500);
                }, { once: true });
                
                input.click();
            });
        }

        // --- Funções de Seleção e Movimento (LÓGICA DE CLIQUE/ARRASTE) ---
        
        function onMouseDown(event) {
            if (event.button !== 0) return;
            if (transformControls.dragging) return;
            if ((cameraMode === 'explore' || cameraMode === 'cinematic') && pointerLockControls && pointerLockControls.isLocked) return;
            if (iconToolbar.contains(event.target) || panelContainer.contains(event.target)) return;
            
            isDragging = false;
            
            const intersect = getIntersectedObject(event.clientX, event.clientY);
            let intersectedObject = null;
            
            if (intersect) {
                intersectedObject = intersect.object;
                while (intersectedObject.parent && !draggableObjects.includes(intersectedObject)) {
                    intersectedObject = intersectedObject.parent;
                }
                if (!draggableObjects.includes(intersectedObject)) {
                     intersectedObject = null;
                }
            }
            
            if (intersectedObject) {
                dragObject = intersectedObject;
                if (orbitControls) orbitControls.enabled = false;
            } else {
                dragObject = null;
            }

            clickTimer = setTimeout(() => {
                isDragging = true;
            }, clickThreshold);
        }
        
        function onMouseUp(event) {
            if (event.button !== 0) return;
            if ((cameraMode === 'explore' || cameraMode === 'cinematic') && pointerLockControls && pointerLockControls.isLocked) return;
            
            clearTimeout(clickTimer);
            
            if (isDragging) {
                // Foi um arraste (drag)
            } else {
                // Foi um clique (click)
                if (!document.body.classList.contains('immersive-mode')) {
                    if (transformControls.dragging) return;
                    
                    if (dragObject) { 
                        setSelectedObject(dragObject);
                    } else {
                        // Clicou no chão
                        setSelectedObject(null);
                        closeContextualPanel();
                        
                        if ((cameraMode === 'explore' || cameraMode === 'cinematic') && pointerLockControls && !pointerLockControls.isLocked) {
                            pointerLockControls.lock();
                        }
                    }
                }
            }
            
            isDragging = false;
            dragObject = null;
            if (orbitControls) orbitControls.enabled = true;
        }
        
        function onMouseMove(event) {
            if (isDragging && dragObject) { 
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                const intersects = raycaster.intersectObjects([...draggableObjects, groundPlane], true);
                
                let targetIntersect = null;
                
                for (const intersect of intersects) {
                    let parentObject = intersect.object;
                    while (parentObject.parent && !draggableObjects.includes(parentObject)) {
                        parentObject = parentObject.parent;
                    }
                    
                    if (parentObject !== dragObject) { 
                        targetIntersect = intersect;
                        break;
                    }
                }

                if (targetIntersect) {
                    const point = targetIntersect.point;
                    dragObject.position.x = point.x;
                    dragObject.position.z = point.z;
                    
                    if (targetIntersect.object.name === "ground") {
                        dragObject.position.y = getRequiredHeightForGround(dragObject);
                    } else {
                        let baseObject = targetIntersect.object;
                        while (baseObject.parent && !draggableObjects.includes(baseObject)) {
                            baseObject = baseObject.parent;
                        }
                        const topY = getObjectBaseHeight(baseObject, false); 
                        const objectBaseOffset = getRequiredHeightForGround(dragObject); 

                        dragObject.position.y = topY + objectBaseOffset;
                    }
                }
            }
        }

        // --- Função de seleção atualizada ---
        function setSelectedObject(object) {
            if (selectedObject === object) return;
            
            selectedObject = object;
            
            // NOVO: Atualiza o OutlinePass
            if (selectedObject) {
                outlinePass.selectedObjects = [selectedObject];
            } else {
                outlinePass.selectedObjects = [];
            }
            
            if(selectedObject && selectedObject.userData.type === 'point_light') {
                lightSelectState = selectedObject.uuid;
            } else if (!selectedObject) {
                lightSelectState = 'none';
            }
            
            const lightSelect = document.getElementById('lightSelect');
            if (lightSelect) {
                lightSelect.value = lightSelectState;
            }

            if (selectedObject) {
                transformControls.attach(selectedObject);
                transformControls.setMode('translate');
            } else {
                transformControls.detach();
            }
        }
        
        // --- Função para atualizar o seletor de luz ---
        function updateLightSelector() {
            const lightSelect = document.getElementById('lightSelect');
            if (!lightSelect) return; 
            
            const selectedId = lightSelectState;
            
            while (lightSelect.options.length > 1) {
                lightSelect.remove(1);
            }

            let lightCount = 1;
            draggableObjects.forEach(obj => {
                if (obj.userData.type === 'point_light') {
                    if (!obj.userData.name) {
                        obj.userData.name = `Luz ${lightCount++}`;
                    }
                    const option = document.createElement('option');
                    option.value = obj.uuid;
                    option.textContent = obj.userData.name;
                    lightSelect.appendChild(option);
                }
            });

            if (draggableObjects.some(o => o.uuid === selectedId && o.userData.type === 'point_light')) {
                lightSelect.value = selectedId;
            } else {
                lightSelect.value = 'none';
                lightSelectState = 'none';
            }
        }
        
        // --- Lógica de Teclado Separada ---

        function onKeyUp(event) {
            switch (event.key) {
                case 'w': case 'W': 
                    moveForward = false;
                    break;
                case 'a': case 'A': 
                    moveLeft = false;
                    break;
                case 's': case 'S': 
                    moveBackward = false;
                    break;
                case 'd': case 'D': 
                    moveRight = false;
                    break;
                case ' ': // Espaço
                    moveUp = false;
                    break;
                case 'Shift':
                    moveDown = false;
                    break;
            }
        }

        function onKeyDown(event) {
            const targetNode = event.target.tagName.toLowerCase();
            if (targetNode === 'input' || targetNode === 'textarea' || targetNode === 'select') return;
            
            if (event.key === 'h' || event.key === 'H') {
                toggleImmersiveMode();
                event.preventDefault();
                return;
            }
            
            if (event.key === 'c' || event.key === 'C') {
                if ((cameraMode === 'explore' || cameraMode === 'cinematic') && pointerLockControls && pointerLockControls.isLocked) {
                    // Não faz nada
                } else {
                    toggleCameraMode();
                }
                event.preventDefault();
                return;
            }

            if ((cameraMode === 'explore' || cameraMode === 'cinematic') && pointerLockControls && pointerLockControls.isLocked) {
                switch (event.key) {
                    case 'w': case 'W':
                        moveForward = true;
                        break;
                    case 'a': case 'A':
                        moveLeft = true;
                        break;
                    case 's': case 'S':
                        moveBackward = true;
                        break;
                    case 'd': case 'D':
                        moveRight = true;
                        break;
                    case ' ': // Espaço
                        moveUp = true;
                        break;
                    case 'Shift':
                        moveDown = true;
                        break;
                }
                if (event.key !== 'Escape') {
                     event.preventDefault();
                }
                return; 
            }
            
            if (event.key === 'r' || event.key === 'R') {
                if (selectedObject && selectedObject.userData.type !== 'point_light') {
                    switch (transformControls.mode) {
                        case 'translate':
                            transformControls.setMode('rotate');
                            break;
                        case 'rotate':
                            transformControls.setMode('scale');
                            break;
                        case 'scale':
                            transformControls.setMode('translate');
                            break;
                    }
                    event.preventDefault();
                }
                if (selectedObject && selectedObject.userData.type === 'point_light') {
                     switch (transformControls.mode) {
                        case 'translate':
                            transformControls.setMode('rotate');
                            break;
                        case 'rotate':
                             transformControls.setMode('translate');
                            break;
                    }
                    event.preventDefault();
                }
                return;
            }

            if (event.key === 'Delete' || event.key === 'Backspace') {
                if (selectedObject) {
                    deleteSelectedObject();
                    event.preventDefault();
                }
                return;
            }

            if (!selectedObject) return;
            if (selectedObject.userData.isGizmoDragging) return; 

            const moveIncrement = 0.25;
            let positionChanged = false;

            switch (event.key) {
                case 'ArrowUp':
                    selectedObject.position.z -= moveIncrement;
                    positionChanged = true;
                    break;
                case 'ArrowDown':
                    selectedObject.position.z += moveIncrement;
                    positionChanged = true;
                    break;
                case 'ArrowLeft':
                    selectedObject.position.x -= moveIncrement;
                    positionChanged = true;
                    break;
                case 'ArrowRight':
                    selectedObject.position.x += moveIncrement;
                    positionChanged = true;
                    break;
                case 'PageUp':
                    selectedObject.position.y += moveIncrement;
                    positionChanged = true;
                    break;
                case 'PageDown':
                    const minY = (selectedObject.userData.type === 'point_light') ? 0.1 : getRequiredHeightForGround(selectedObject);
                    const targetY = selectedObject.position.y - moveIncrement;
                    selectedObject.position.y = Math.max(minY, targetY);
                    positionChanged = true;
                    break;
                case 'Escape':
                    setSelectedObject(null);
                    closeContextualPanel();
                    break;
            }

            if (positionChanged) {
                event.preventDefault();
            }
        }

    </script>
</body>
</html>
