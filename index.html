<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTT 3D Local</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/lucide-react/0.395.0/lucide.min.js" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
        }
        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #uiPanel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(26, 26, 26, 0.9);
            color: #f0f0f0;
            border-radius: 12px;
            padding: 16px;
            width: 300px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease-in-out;
        }
        #uiPanel.hidden {
            transform: translateX(-320px);
        }
        #toggleUiBtn {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1001;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
        }
        #uiPanel:not(.hidden) + #toggleUiBtn {
            left: 320px; /* Posição quando o painel está visível */
        }
        .control-group {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .control-group:last-of-type {
            border-bottom: none;
            margin-bottom: 0;
        }
        h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: #a7f3d0; /* Verde menta */
        }
        button, .file-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 10px;
            background-color: #3f3f46; /* Cinza-zinco 700 */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 8px;
            transition: background-color 0.2s;
        }
        button:hover, .file-label:hover {
            background-color: #52525b; /* Cinza-zinco 600 */
        }
        select {
            width: 100%;
            padding: 10px;
            background-color: #3f3f46;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 8px;
        }
        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
        }
        input[type="range"] {
            width: 100%;
        }
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            color: #d4d4d8;
            margin-top: 8px;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        
        /* CSS para Modo Imersivo */
        body.immersive-mode #uiPanel,
        body.immersive-mode #toggleUiBtn {
            display: none;
        }
    </style>

    <!-- Importmap: Define os módulos do Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/",
                "three/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/controls/OrbitControls.js",
                "three/controls/TransformControls": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/controls/TransformControls.js",
                "three/controls/PointerLockControls": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/controls/PointerLockControls.js",
                "three/loaders/GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/loaders/GLTFLoader.js",
                "three/postprocessing/EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/EffectComposer.js",
                "three/postprocessing/RenderPass": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/RenderPass.js",
                "three/shaders/BokehShader": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/shaders/BokehShader.js",
                "three/postprocessing/BokehPass": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/BokehPass.js",
                "three/postprocessing/OutputPass": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/postprocessing/OutputPass.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvasContainer"></div>

    <div id="uiPanel">
        <div class="control-group">
            <h3>Cena</h3>
            <label for="loadSceneInput" class="file-label">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                Carregar Cena (.json)
            </label>
            <input type="file" id="loadSceneInput" accept=".json" class="hidden">
            <button id="saveSceneBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                Salvar Cena (.json)
            </button>

            <label for="skyboxSelect" class="slider-label">Céu e Iluminação</label>
            <select id="skyboxSelect">
                <option value="default">Padrão (Escuro)</option>
                <option value="day">Dia (Parque)</option>
                <option value="sunset">Pôr do Sol (Ponte)</option>
                <option value="night">Noite (Via Láctea)</option>
                <!-- Opções customizadas serão adicionadas aqui via JS -->
            </select>
            
            <label for="loadSkyboxInput" class="file-label">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.2 15c.7-1.2 1-2.5.7-3.9-.6-2.4-2.4-4.2-4.8-4.8-1.4-.3-2.7-.1-3.9.7L12 8l-1.2-1.1c-1.2-.7-2.5-1-3.9-.7-2.4.6-4.2 2.4-4.8 4.8-.3 1.4-.1 2.7.7 3.9L4 16.5 12 22l8-5.5-1.2-1.5z"></path></svg>
                Carregar Céu Customizado (360)
            </label>
            <input type="file" id="loadSkyboxInput" accept="image/png, image/jpeg" class="hidden">
        </div>

        <!-- Controles do Chão -->
        <div class="control-group">
            <h3>Propriedades do Chão</h3>
            <div class="slider-group">
                <label for="groundRoughnessSlider" class="slider-label">
                    <span>Rugosidade (Espelho)</span>
                    <span id="groundRoughnessValue">0.8</span>
                </label>
                <input type="range" id="groundRoughnessSlider" min="0" max="1" value="0.8" step="0.01">
            </div>
            <div class="slider-group">
                <label for="groundMetalnessSlider" class="slider-label">
                    <span>Metalicidade (Reflexo)</span>
                    <span id="groundMetalnessValue">0.2</span>
                </label>
                <input type="range" id="groundMetalnessSlider" min="0" max="1" value="0.2" step="0.01">
            </div>
        </div>

        <div class="control-group">
            <h3>Tokens</h3>
            <button id="addCubeBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
                Adicionar Cubo
            </button>
            <button id="addSphereBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle></svg>
                Adicionar Esfera
            </button>

            <label for="loadImageInput" class="file-label">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                Carregar Token Imagem
            </label>
            <input type="file" id="loadImageInput" accept="image/png, image/jpeg" class="hidden">

            <label for="loadModelInput" class="file-label">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m20 18-5-5-5 5-5-5"></path><path d="m4 8 5 5 5-5 5 5"></path></svg>
                Carregar Modelo (.glb)
            </label>
            <input type="file" id="loadModelInput" accept=".glb" class="hidden">
        </div>

        <div class="control-group">
            <h3>Luzes</h3>
            <input type="color" id="lightColorInput" value="#ffffff">
            <button id="addLightBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path><path d="M12 3v1"></path><path d="M20.66 7 20 7.66"></path><path d="M21 12h-1"></path><path d="M20 16.34 20.66 17"></path><path d="M12 21v-1"></path><path d="M7.66 20 7 20.66"></path><path d="M3 12h1"></path><path d="M4 7.66 3.34 7"></path></svg>
                Adicionar Luz
            </button>
            
            <!-- NOVO SELETOR DE LUZ -->
            <label for="lightSelect" class="slider-label">Selecionar Luz</label>
            <select id="lightSelect">
                <option value="none">Nenhuma</option>
                <!-- Luzes adicionadas aqui via JS -->
            </select>
        </div>
        
        <div class="control-group">
            <h3>Câmera (Filtros)</h3>
            <div class="slider-group">
                <label for="fovSlider" class="slider-label">
                    <span>Campo de Visão (FOV)</span>
                    <span id="fovValue">60</span>
                </label>
                <input type="range" id="fovSlider" min="20" max="120" value="60">
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="dofToggle">
                <label for="dofToggle">Profundidade de Campo (DOF)</label>
            </div>
            
            <div id="dofFocusControls" class="slider-group hidden">
                <label for="dofFocusSlider" class="slider-label">
                    <span>Distância Foco</span>
                    <span id="dofFocusValue">20.0</span>
                </label>
                <input type="range" id="dofFocusSlider" min="1" max="100" value="20" step="0.1">
            </div>
            
            <div id="dofApertureControls" class="slider-group hidden">
                <label for="dofApertureSlider" class="slider-label">
                    <span>Abertura (Desfoque)</span>
                    <span id="dofApertureValue">5.0</span>
                </label>
                <input type="range" id="dofApertureSlider" min="0" max="20" value="5" step="0.1">
            </div>
        </div>

        <!-- MODO DE CÂMERA -->
        <div class="control-group">
            <h3>Modo de Câmera (Atalho: C)</h3>
            <button id="cameraModeBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 19l-2-2-2 2"></path><path d="M7 21v-4"></path><path d="M7 13A6 6 0 0 0 7 1a6 6 0 0 0 0 12z"></path><path d="M15 13a6 6 0 0 0 0-12 6 6 0 0 0-1 3.5"></path></svg>
                Modo: Orbitar
            </button>
            <p id="cameraHelpText" class="text-xs text-gray-400 mt-2 hidden">
                Modo Explorar: Use WASD para mover, Espaço/Shift para subir/descer, e o Mouse para olhar. Clique na cena para travar. (Aperte ESC para destravar)
            </p>
        </div>
    </div>

    <!-- Botão de Toggle da UI -->
    <button id="toggleUiBtn">
        <!-- Ícone de Menu (Hamburguer) -->
        <svg id="menuIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
        <!-- Ícone de Fechar (X) -->
        <svg id="closeIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
    </button>


    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/controls/OrbitControls';
        import { TransformControls } from 'three/controls/TransformControls';
        import { PointerLockControls } from 'three/controls/PointerLockControls';
        import { GLTFLoader } from 'three/loaders/GLTFLoader';
        import { EffectComposer } from 'three/postprocessing/EffectComposer';
        import { RenderPass } from 'three/postprocessing/RenderPass';
        import { BokehPass } from 'three/postprocessing/BokehPass';
        import { OutputPass } from 'three/postprocessing/OutputPass';

        let scene, camera, renderer, orbitControls, transformControls;
        let groundPlane, ambientLight, sunLight;
        const canvasContainer = document.getElementById('canvasContainer');
        
        // Controles de Câmera FPS
        let pointerLockControls = null;
        let cameraMode = 'orbit'; 
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const clock = new THREE.Clock(); 

        // Botões da UI
        const addCubeBtn = document.getElementById('addCubeBtn');
        const addSphereBtn = document.getElementById('addSphereBtn');
        const addLightBtn = document.getElementById('addLightBtn');
        const lightColorInput = document.getElementById('lightColorInput');
        const loadImageInput = document.getElementById('loadImageInput');
        const loadModelInput = document.getElementById('loadModelInput');
        const toggleUiBtn = document.getElementById('toggleUiBtn');
        const uiPanel = document.getElementById('uiPanel');
        const menuIcon = document.getElementById('menuIcon');
        const closeIcon = document.getElementById('closeIcon');
        
        // Controles de Câmera (Filtros)
        const fovSlider = document.getElementById('fovSlider');
        const fovValue = document.getElementById('fovValue');
        const dofToggle = document.getElementById('dofToggle');
        const dofFocusSlider = document.getElementById('dofFocusSlider');
        const dofFocusValue = document.getElementById('dofFocusValue');
        const dofApertureSlider = document.getElementById('dofApertureSlider');
        const dofApertureValue = document.getElementById('dofApertureValue');
        const dofFocusControls = document.getElementById('dofFocusControls');
        const dofApertureControls = document.getElementById('dofApertureControls');
        
        // Botão de Modo Câmera
        const cameraModeBtn = document.getElementById('cameraModeBtn');
        const cameraHelpText = document.getElementById('cameraHelpText');
        
        // Salvar/Carregar Cena
        const saveSceneBtn = document.getElementById('saveSceneBtn');
        const loadSceneInput = document.getElementById('loadSceneInput');
        const skyboxSelect = document.getElementById('skyboxSelect');
        const loadSkyboxInput = document.getElementById('loadSkyboxInput'); 
        
        // Controles do Chão
        const groundRoughnessSlider = document.getElementById('groundRoughnessSlider');
        const groundRoughnessValue = document.getElementById('groundRoughnessValue');
        const groundMetalnessSlider = document.getElementById('groundMetalnessSlider');
        const groundMetalnessValue = document.getElementById('groundMetalnessValue');
        
        // NOVO: Seletor de Luz
        const lightSelect = document.getElementById('lightSelect');
        
        // Armazenamento de Recursos Carregados
        const loadedResources = new Map();

        let draggableObjects = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedObject = null;

        // Pós-processamento
        let composer, bokehPass, renderPass;

        // Lógica de Clique vs Arraste
        let clickTimer = null;
        let isDragging = false;
        const clickThreshold = 300; 
        let dragObject = null;

        let customSkyboxResourceName = null;

        init();
        animate();

        function init() {
            // Cena
            scene = new THREE.Scene();

            // Câmera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 20, 25); 

            // Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            canvasContainer.appendChild(renderer.domElement);
            
            // Pós-processamento
            setupPostProcessing();
            
            // Luzes
            ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
            sunLight.position.set(20, 30, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            sunLight.shadow.bias = -0.0005;
            sunLight.shadow.normalBias = 0.05;
            scene.add(sunLight);
            
            loadSkybox('default');

            // Chão
            groundPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ 
                    color: 0x444444, 
                    side: THREE.DoubleSide, 
                    roughness: 0.8, 
                    metalness: 0.2
                })
            );
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.receiveShadow = true;
            groundPlane.name = "ground";
            scene.add(groundPlane);

            // Grid
            const gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0x888888);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Controles da Câmera (Órbita)
            createOrbitControls();
            
            canvasContainer.addEventListener('click', () => {
                if (cameraMode === 'explore' && pointerLockControls && !pointerLockControls.isLocked) {
                    pointerLockControls.lock();
                }
            });

            // Controles de Transformação (Gizmo)
            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', (event) => {
                // *** CORREÇÃO 2: Desabilita a câmera ao arrastar o gizmo ***
                if (orbitControls) orbitControls.enabled = !event.value;
                
                if (selectedObject) {
                    selectedObject.userData.isGizmoDragging = event.value;
                }
            });
            transformControls.addEventListener('objectChange', () => {
                if (selectedObject) {
                    const minY = getRequiredHeightForGround(selectedObject);
                    if (selectedObject.position.y < minY && selectedObject.userData.type !== 'model_glb') {
                         selectedObject.position.y = minY;
                    } else if (selectedObject.userData.type === 'model_glb') {
                        // Lógica de GLB para base
                        const box = new THREE.Box3().setFromObject(selectedObject);
                        const currentBaseY = box.min.y;
                        if(currentBaseY < 0) {
                            selectedObject.position.y -= currentBaseY; // Empurra para cima
                        }
                    }
                }
            });
            transformControls.setSize(1.0);
            scene.add(transformControls);

            // Listeners de eventos
            window.addEventListener('resize', onWindowResize);
            addCubeBtn.addEventListener('click', () => addNewToken('cube'));
            addSphereBtn.addEventListener('click', () => addNewToken('sphere'));
            addLightBtn.addEventListener('click', () => {
                const color = lightColorInput.value;
                addNewToken('point_light', { color: color });
            });
            
            canvasContainer.addEventListener('mousedown', onMouseDown, false); 
            canvasContainer.addEventListener('mouseup', onMouseUp, false); 
            canvasContainer.addEventListener('mousemove', onMouseMove, false); 
            
            window.addEventListener('keydown', onKeyDown, false); 
            window.addEventListener('keyup', onKeyUp, false);

            // UI
            toggleUiBtn.addEventListener('click', () => {
                uiPanel.classList.toggle('hidden');
                menuIcon.classList.toggle('hidden');
                closeIcon.classList.toggle('hidden');
                toggleUiBtn.style.left = uiPanel.classList.contains('hidden') ? '10px' : '320px';
            });
            
            // Controles de Câmera
            setupCameraControls();
            
            // Botão de Modo Câmera (REFATORADO)
            cameraModeBtn.addEventListener('click', toggleCameraMode);
            
            // Salvar/Carregar
            saveSceneBtn.addEventListener('click', saveScene);
            loadSceneInput.addEventListener('change', loadScene);
            skyboxSelect.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    if (customSkyboxResourceName) {
                        const dataURL = loadedResources.get(customSkyboxResourceName);
                        if (dataURL) {
                            loadSkybox('custom', dataURL);
                        } else {
                            handleLoadCustomSkybox(); 
                        }
                    } else {
                        handleLoadCustomSkybox();
                    }
                } else {
                    loadSkybox(e.target.value);
                }
            });
            
            // Listeners dos sliders do Chão
            groundRoughnessSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                groundPlane.material.roughness = value;
                groundRoughnessValue.textContent = value.toFixed(2);
            });
            groundMetalnessSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                groundPlane.material.metalness = value;
                groundMetalnessValue.textContent = value.toFixed(2);
            });
            
            // Inputs de Arquivo
            setupFileInputs();
            
            // NOVO: Listener do Seletor de Luz
            lightSelect.addEventListener('change', () => {
                const selectedId = lightSelect.value;
                if (selectedId === 'none') {
                    setSelectedObject(null);
                } else {
                    const lightObject = draggableObjects.find(o => o.uuid === selectedId);
                    if (lightObject) {
                        setSelectedObject(lightObject);
                    }
                }
            });
        }
        
        // --- FUNÇÕES DE CONTROLES DE CÂMERA ---
        function createOrbitControls() {
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.maxPolarAngle = Math.PI / 2.1;
        }
        
        function createPointerLockControls() {
            pointerLockControls = new PointerLockControls(camera, renderer.domElement);
            scene.add(pointerLockControls.getObject());
            
            pointerLockControls.addEventListener('lock', () => {
                if (!uiPanel.classList.contains('hidden')) {
                    toggleUiBtn.click(); 
                }
            });
        }
        
        // NOVO: Função refatorada para trocar de câmera
        function toggleCameraMode() {
            if (cameraMode === 'orbit') {
                // --- MUDANDO PARA MODO EXPLORAR ---
                cameraMode = 'explore';
                cameraModeBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0-18 0Z"></path><path d="M21 12c0-4.97-4.03-9-9-9"></path><path d="m2 16 3-3"></path><path d="m13 8 3-3 3 3"></path><path d="M16 2v3"></path><path d="M8 22v-3"></path></svg>
                    Modo: Explorar`;
                cameraHelpText.classList.remove('hidden');
                
                if (orbitControls) {
                    orbitControls.dispose();
                    orbitControls = null;
                }
                
                createPointerLockControls();
                
                camera.position.set(0, 1.8, 10);
                pointerLockControls.getObject().position.copy(camera.position);
                
                transformControls.enabled = false; 

            } else {
                // --- MUDANDO PARA MODO ORBITAR ---
                cameraMode = 'orbit';
                cameraModeBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 19l-2-2-2 2"></path><path d="M7 21v-4"></path><path d="M7 13A6 6 0 0 0 7 1a6 6 0 0 0 0 12z"></path><path d="M15 13a6 6 0 0 0 0-12 6 6 0 0 0-1 3.5"></path></svg>
                    Modo: Orbitar`;
                cameraHelpText.classList.add('hidden');
                
                if (pointerLockControls) {
                    scene.remove(pointerLockControls.getObject());
                    pointerLockControls.dispose();
                    pointerLockControls = null;
                }
                
                createOrbitControls();
                
                camera.position.set(15, 20, 25);
                orbitControls.target.set(0, 0, 0); 

                transformControls.enabled = true; 
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (cameraMode === 'orbit' && orbitControls) {
                orbitControls.update();
            } else if (cameraMode === 'explore' && pointerLockControls) {
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= velocity.y * 10.0 * delta; 

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.y = Number(moveUp) - Number(moveDown);
                direction.normalize(); 

                const speed = 40.0;
                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
                if (moveUp || moveDown) velocity.y -= direction.y * speed * delta;

                pointerLockControls.moveRight(-velocity.x * delta);
                pointerLockControls.moveForward(-velocity.z * delta);
                pointerLockControls.getObject().position.y += (velocity.y * delta);

                if (pointerLockControls.getObject().position.y < 0.5) {
                    pointerLockControls.getObject().position.y = 0.5;
                    velocity.y = 0;
                }
            }

            // Rotação horizontal dos sprites
            const cameraPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraPosition);

            for (const object of draggableObjects) {
                if (object.userData.type === 'image_sprite') {
                    cameraPosition.y = object.position.y;
                    object.lookAt(cameraPosition);
                }
            }
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Função para Carregar Skybox e Iluminação ---
        function loadSkybox(name, customDataURL = null) {
            
            if (name === 'custom' && customDataURL) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(customDataURL, (texture) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    texture.encoding = THREE.sRGBEncoding;
                    scene.background = texture;
                    scene.environment = texture;
                    
                    if (ambientLight) ambientLight.intensity = 0.2;
                    if (sunLight) {
                        sunLight.intensity = 3.0;
                        sunLight.color.set(0xffffff);
                    }
                });
                return;
            }

            const cubeTextureLoader = new THREE.CubeTextureLoader();
            let path, format, urls;
            
            switch(name) {
                case 'day':
                    path = 'https://threejs.org/examples/textures/cube/Park2/';
                    format = '.jpg';
                    urls = [
                        path + 'px' + format, path + 'nx' + format,
                        path + 'py' + format, path + 'ny' + format,
                        path + 'pz' + format, path + 'nz' + format
                    ];
                    break;
                case 'sunset':
                    path = 'https://threejs.org/examples/textures/cube/Bridge2/';
                    format = '.jpg';
                    urls = [
                        path + 'px' + format, path + 'nx' + format,
                        path + 'py' + format, path + 'ny' + format,
                        path + 'pz' + format, path + 'nz' + format
                    ];
                    break;
                case 'night':
                    path = 'https://threejs.org/examples/textures/cube/MilkyWay/';
                    format = '.jpg';
                    urls = [
                        path + 'px' + format, path + 'nx' + format,
                        path + 'py' + format, path + 'ny' + format,
                        path + 'pz' + format, path + 'nz' + format
                    ];
                    break;
                case 'default':
                default:
                    urls = [
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+',
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+',
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+',
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+',
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+',
                        'https://placehold.co/1024x1024/2a2a2a/2a2a2a?text=+'
                    ];
                    break;
            }

            const texture = cubeTextureLoader.load(urls, () => {
                texture.encoding = THREE.sRGBEncoding; 
                scene.background = texture;
                scene.environment = texture;
            });

            // Ajusta as luzes manuais para complementar o skybox
            switch(name) {
                case 'day':
                    if (ambientLight) ambientLight.intensity = 0.2;
                    if (sunLight) {
                        sunLight.intensity = 3.0;
                        sunLight.color.set(0xffffff);
                    }
                    break;
                case 'sunset':
                    if (ambientLight) ambientLight.intensity = 0.1;
                    if (sunLight) {
                        sunLight.intensity = 2.5;
                        sunLight.color.set(0xffaa88);
                    }
                    break;
                case 'night':
                    if (ambientLight) ambientLight.intensity = 0.05;
                    if (sunLight) {
                        sunLight.intensity = 0.5;
                        sunLight.color.set(0xaaaaff);
                    }
                    break;
                case 'default':
                default:
                    if (ambientLight) ambientLight.intensity = 0.3;
                    if (sunLight) {
                        sunLight.intensity = 2.0;
                        sunLight.color.set(0xffffff);
                    }
                    break;
            }
        }

        // --- Funções de Câmera Cinematográfica ---
        
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            bokehPass = new BokehPass(scene, camera, {
                focus: 20.0,
                aperture: 5.0,
                maxblur: 0.005,
                width: window.innerWidth,
                height: window.innerHeight
            });
            bokehPass.enabled = false;
            composer.addPass(bokehPass);

            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        function setupCameraControls() {
            fovSlider.addEventListener('input', (e) => {
                camera.fov = parseFloat(e.target.value);
                camera.updateProjectionMatrix();
                fovValue.textContent = e.target.value;
            });
            
            dofToggle.checked = false;
            dofFocusControls.classList.toggle('hidden', true); 
            dofApertureControls.classList.toggle('hidden', true); 
            
            dofToggle.addEventListener('change', (e) => {
                bokehPass.enabled = e.target.checked;
                dofFocusControls.classList.toggle('hidden', !e.target.checked);
                dofApertureControls.classList.toggle('hidden', !e.target.checked);
            });
            
            dofFocusSlider.addEventListener('input', (e) => {
                bokehPass.uniforms['focus'].value = parseFloat(e.target.value);
                dofFocusValue.textContent = parseFloat(e.target.value).toFixed(1);
            });
            
            dofApertureSlider.addEventListener('input', (e) => {
                bokehPass.uniforms['aperture'].value = parseFloat(e.target.value) * 1e-5;
                dofApertureValue.textContent = parseFloat(e.target.value).toFixed(1);
            });
        }
        
        // --- Funções de Salvar/Carregar Cena ---
        
        async function saveScene() {
            const sceneData = {
                tokens: [],
                resources: Array.from(loadedResources.entries()),
                skybox: {
                    name: skyboxSelect.value,
                    resourceName: (skyboxSelect.value === 'custom') ? customSkyboxResourceName : null
                },
                groundMaterial: {
                    roughness: groundPlane.material.roughness,
                    metalness: groundPlane.material.metalness
                }
            };
            
            draggableObjects.forEach(obj => {
                const data = {
                    type: obj.userData.type,
                    position: obj.position.clone(),
                    scale: obj.scale.clone(),
                    rotation: obj.rotation.clone(),
                };
                
                if (obj.userData.type === 'point_light') {
                    data.color = obj.userData.light.color.getHex();
                    data.intensity = obj.userData.light.intensity;
                    data.name = obj.userData.name; // Salva o nome da luz
                } else if (obj.userData.type === 'image_sprite' || obj.userData.type === 'model_glb') {
                    data.resourceName = obj.userData.resourceName;
                }
                
                sceneData.tokens.push(data);
            });
            
            const jsonString = JSON.stringify(sceneData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'vtt-scene.json';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function loadScene(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const sceneData = JSON.parse(e.target.result);
                    
                    clearScene();
                    
                    removeCustomSkyboxOption();
                    
                    if (sceneData.resources) {
                        for (const [name, dataURL] of sceneData.resources) {
                            loadedResources.set(name, dataURL);
                        }
                    }
                    
                    if (sceneData.tokens) {
                        for (const data of sceneData.tokens) {
                            await addNewToken(data.type, data);
                        }
                    }
                    
                    // Atualiza o seletor de luz DEPOIS que todas as luzes foram carregadas
                    updateLightSelector();
                    
                    if (sceneData.skybox) {
                        if (sceneData.skybox.name === 'custom' && sceneData.skybox.resourceName) {
                            customSkyboxResourceName = sceneData.skybox.resourceName;
                            let dataURL = loadedResources.get(customSkyboxResourceName);
                            if (!dataURL) {
                                try {
                                    dataURL = await requestResourceFile(
                                         `Por favor, selecione o arquivo do Céu Customizado: ${customSkyboxResourceName}`,
                                         'image/*',
                                         500 * 1024 * 1024 // 500MB
                                    );
                                    loadedResources.set(customSkyboxResourceName, dataURL);
                                } catch (err) {
                                    alert(err.message);
                                    loadSkybox('default');
                                    skyboxSelect.value = 'default';
                                    return; 
                                }
                            }
                            addCustomSkyboxOption();
                            skyboxSelect.value = 'custom';
                            loadSkybox('custom', dataURL);
                            
                        } else {
                            skyboxSelect.value = sceneData.skybox.name || 'default';
                            loadSkybox(skyboxSelect.value);
                        }
                    } else {
                        skyboxSelect.value = 'default';
                        loadSkybox('default');
                    }
                    
                    if (sceneData.groundMaterial) {
                        const { roughness, metalness } = sceneData.groundMaterial;
                        groundPlane.material.roughness = roughness;
                        groundPlane.material.metalness = metalness;
                        
                        groundRoughnessSlider.value = roughness;
                        groundRoughnessValue.textContent = roughness.toFixed(2);
                        groundMetalnessSlider.value = metalness;
                        groundMetalnessValue.textContent = metalness.toFixed(2);
                    } else {
                        groundPlane.material.roughness = 0.8;
                        groundPlane.material.metalness = 0.2;
                        groundRoughnessSlider.value = 0.8;
                        groundRoughnessValue.textContent = (0.8).toFixed(2);
                        groundMetalnessSlider.value = 0.2;
                        groundMetalnessValue.textContent = (0.2).toFixed(2);
                    }
                    
                } catch (err) {
                    console.error("Erro ao carregar a cena:", err);
                    alert("Erro: Não foi possível ler o arquivo de cena.");
                }
            };
            reader.readText(file);
        }
        
        function clearScene() {
            setSelectedObject(null); 
            
            while (draggableObjects.length > 0) {
                const obj = draggableObjects.pop();
                
                if (obj.userData.light) {
                    scene.remove(obj.userData.light);
                }
                
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (obj.material.map) obj.material.map.dispose();
                    obj.material.dispose();
                }
                
                scene.remove(obj);
            }
            
            updateLightSelector(); // Limpa o seletor
        }

        // --- Funções de Tokens e Objetos ---
        
        async function addNewToken(type, data = {}) {
            let mesh;
            const position = data.position ? new THREE.Vector3(data.position.x, data.position.y, data.position.z) : getSpawnPosition();
            const scale = data.scale ? new THREE.Vector3(data.scale.x, data.scale.y, data.scale.z) : new THREE.Vector3(1, 1, 1);
            const rotation = data.rotation ? new THREE.Euler(data.rotation._x, data.rotation._y, data.rotation._z) : new THREE.Euler(0, 0, 0);

            let resourceDataURL = null;
            
            if (data.resourceName) {
                resourceDataURL = loadedResources.get(data.resourceName);
                if (!resourceDataURL) {
                     alert(`Recurso "${data.resourceName}" não encontrado. Por favor, recarregue o arquivo.`);
                     try {
                         const accept = data.type === 'image_sprite' ? 'image/*' : '.glb';
                         resourceDataURL = await requestResourceFile(
                             `Por favor, selecione o arquivo para: ${data.resourceName}`,
                             accept,
                             500 * 1024 * 1024 // 500MB
                         );
                         loadedResources.set(data.resourceName, dataURL);
                     } catch(err) {
                         alert(err.message);
                         return;
                     }
                }
            } 

            if (type === 'image_sprite') {
                mesh = await createTokenMesh(type, resourceDataURL);
                if (mesh.material.map && mesh.material.map.image) {
                     mesh.userData.aspectRatio = (mesh.material.map.image.height / mesh.material.map.image.width) || 1;
                } else {
                    mesh.userData.aspectRatio = 1;
                }
            } else if (type === 'model_glb') {
                mesh = await createTokenMesh(type, resourceDataURL);
            } else {
                mesh = await createTokenMesh(type, data); // Cubo, Esfera, Luz
            }

            mesh.position.copy(position);
            mesh.scale.copy(scale);
            mesh.rotation.copy(rotation);
            
            scene.add(mesh);
            
            if (!data.position) {
                if (type === 'point_light') {
                    mesh.position.y = 3;
                } else {
                    mesh.position.y = getRequiredHeightForGround(mesh);
                }
            }

            mesh.userData.type = type;
            mesh.userData.resourceName = data.resourceName || null;
            mesh.userData.isDragging = false;
            mesh.userData.isGizmoDragging = false;
            
            if (type === 'point_light') {
                // Seta um nome se não tiver um (do save/load)
                if (!data.name) {
                    const lightCount = draggableObjects.filter(o => o.userData.type === 'point_light').length + 1;
                    mesh.userData.name = `Luz ${lightCount}`;
                } else {
                    mesh.userData.name = data.name;
                }
            }
            
            if (type !== 'point_light') {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
            }

            draggableObjects.push(mesh);
            
            if (type === 'point_light') {
                updateLightSelector(); // Atualiza o dropdown
            }
            
            return mesh;
        }
        
        function getObjectBaseHeight(object, getBase = false) {
            if (!object) return 0;
            
            if (object.userData.type === 'image_sprite') {
                return getBase ? 0 : object.position.y + object.scale.y / 2;
            } 
            
            // Para luzes (que são invisíveis), retorna a posição
            if (object.userData.type === 'point_light') {
                return getBase ? object.position.y : object.position.y;
            }
            
            const box = new THREE.Box3().setFromObject(object);

            if (object.userData.type === 'model_glb') {
                return getBase ? box.min.y : box.max.y;
            }
            
            return getBase ? box.min.y : box.max.y;
        }

        function getRequiredHeightForGround(object) {
            if (!object) return 0;

            if (object.userData.type === 'image_sprite') {
                return object.scale.y / 2;
            }

            if (object.userData.type === 'model_glb') {
                const box = new THREE.Box3().setFromObject(object);
                const height = box.max.y - box.min.y;
                return height / 2;
            }

            if (object.userData.type === 'cube') {
                return object.scale.y / 2;
            }
            
            if (object.userData.type === 'sphere') {
                return object.scale.y / 2;
            }

            return 0; // Padrão (incluindo luzes)
        }


        function createTokenMesh(type, data) {
            return new Promise((resolve, reject) => {
                let mesh;
                if (type === 'image_sprite') {
                    if (!data) return reject(new Error('Dados da imagem não fornecidos para o sprite.'));
                    const texture = new THREE.TextureLoader().load(data, (tex) => {
                        const aspectRatio = tex.image.height / tex.image.width;
                        mesh.userData.aspectRatio = aspectRatio;
                        if (mesh.scale.x === 1 && mesh.scale.y === 1) {
                             mesh.scale.set(2, 2 * aspectRatio, 1);
                        }
                        resolve(mesh);
                    }, undefined, (err) => reject(new Error('Falha ao carregar a textura da imagem: ' + err.message)));
                    
                    texture.encoding = THREE.sRGBEncoding;
                    const material = new THREE.MeshStandardMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide,
                        alphaTest: 0.1,
                        roughness: 0.8,
                        metalness: 0.1
                    });
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    mesh = new THREE.Mesh(geometry, material);

                } else if (type === 'model_glb') {
                    if (!data) return reject(new Error('Dados do modelo não fornecidos para o GLB.'));
                    const loader = new GLTFLoader();
                    loader.load(data, (gltf) => {
                        mesh = gltf.scene;
                        const box = new THREE.Box3().setFromObject(mesh);
                        const center = box.getCenter(new THREE.Vector3());
                        mesh.position.sub(center); 
                        
                        if (mesh.scale.x === 1 && mesh.scale.y === 1) {
                            const size = box.getSize(new THREE.Vector3());
                            const maxDim = Math.max(size.x, size.y, size.z);
                            const scale = 2 / maxDim;
                            mesh.scale.set(scale, scale, scale);
                        }
                        resolve(mesh);
                    }, undefined, (err) => reject(new Error('Falha ao carregar o modelo GLB: ' + err.message)));

                } else if (type === 'point_light') {
                    const lightColor = data.color ? data.color : 0xffffff;
                    const intensity = data.intensity ? data.intensity : 20.0;
                    
                    const pointLight = new THREE.PointLight(lightColor, intensity, 20);
                    pointLight.castShadow = true;
                    pointLight.shadow.bias = -0.001;
                    pointLight.shadow.normalBias = 0.05;
                    
                    // *** CORREÇÃO 1: O material fica invisível, mas o "mesh" (dono da luz) não. ***
                    const gizmoMaterial = new THREE.MeshBasicMaterial({ color: lightColor });
                    gizmoMaterial.transparent = true;
                    gizmoMaterial.opacity = 0;
                    
                    const gizmoGeometry = new THREE.SphereGeometry(0.1, 8, 4); // Pode ser minúsculo
                    mesh = new THREE.Mesh(gizmoGeometry, gizmoMaterial); 
                    
                    // mesh.visible = false; // <-- ESTA ERA A LINHA DO BUG, REMOVIDA.
                    
                    mesh.add(pointLight);
                    mesh.userData.light = pointLight;
                    resolve(mesh);
                } else {
                    const geometry = (type === 'cube') ? new THREE.BoxGeometry(1, 1, 1) : new THREE.SphereGeometry(0.5, 32, 16);
                    const material = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5, metalness: 0.1 });
                    mesh = new THREE.Mesh(geometry, material);
                    resolve(mesh);
                }
            });
        }
        
        function deleteSelectedObject() {
            if (!selectedObject) return;
            
            const objectToDelete = selectedObject;
            const wasLight = objectToDelete.userData.type === 'point_light';
            
            setSelectedObject(null);
            
            scene.remove(objectToDelete);
            
            if (objectToDelete.userData.light) {
                // A luz é filha, será removida junto
            }

            if (objectToDelete.geometry) objectToDelete.geometry.dispose();
            if (objectToDelete.material) {
                if (objectToDelete.material.map) objectToDelete.material.map.dispose();
                objectToDelete.material.dispose();
            }
            objectToDelete.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                }
            });

            const index = draggableObjects.indexOf(objectToDelete);
            if (index > -1) {
                draggableObjects.splice(index, 1);
            }
            
            if (wasLight) {
                updateLightSelector(); // Atualiza o dropdown
            }
        }

        
        function getIntersectedObject(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // Intersecta apenas objetos visíveis (luzes são mesh.visible = false, então são ignoradas)
            const intersects = raycaster.intersectObjects([...draggableObjects, groundPlane], true); 
            
            const objectIntersect = intersects.find(intersect => intersect.object.name !== "ground");
            
            if (objectIntersect) return objectIntersect;

            return intersects.find(intersect => intersect.object.name === "ground") || null;
        }
        
        function getSpawnPosition() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const pos = raycaster.ray.at(15, new THREE.Vector3());
            pos.y = 0; // Será corrigido em addNewToken
            return pos;
        }
        
        // --- Funções de Leitura de Arquivo ---

        function setupFileInputs() {
            [loadImageInput, loadModelInput, loadSceneInput, loadSkyboxInput].forEach(input => {
                input.style.display = 'none';
            });
            
            loadImageInput.addEventListener('change', (e) => handleFileToken(e, 'image_sprite'));
            loadModelInput.addEventListener('change', (e) => handleFileToken(e, 'model_glb'));
            loadSkyboxInput.addEventListener('change', handleLoadCustomSkybox); 
        }
        
        async function handleFileToken(event, type) {
            const file = event.target.files[0];
            if (!file) return;

            const maxSize = 500 * 1024 * 1024; // 500MB
            if (file.size > maxSize) {
                alert(`Erro: O ficheiro é muito grande (${(file.size / 1024 / 1024).toFixed(1)}MB). O limite é 500MB.`);
                event.target.value = null; 
                return;
            }

            try {
                const dataURL = await fileToDataURL(file);
                const resourceName = `${type}_${file.name}_${Date.now()}`;
                loadedResources.set(resourceName, dataURL);
                
                await addNewToken(type, { resourceName: resourceName });
            } catch (err) {
                alert("Erro ao ler o ficheiro: " + err.message);
            }
            
            event.target.value = null; 
        }
        
        async function handleLoadCustomSkybox(event) {
            let file;
            if(event) {
                file = event.target.files[0];
            } else {
                try {
                     const dataURL = await requestResourceFile(
                        "Por favor, selecione seu arquivo de céu customizado (360).",
                        'image/*',
                        500 * 1024 * 1024 // 500MB
                    );
                    const resourceName = `skybox_custom_${Date.now()}`;
                    loadedResources.set(resourceName, dataURL);
                    customSkyboxResourceName = resourceName;
                    addCustomSkyboxOption();
                    skyboxSelect.value = 'custom';
                    loadSkybox('custom', dataURL);
                    return;

                } catch (err) {
                    alert(err.message);
                    skyboxSelect.value = 'default'; 
                    return;
                }
            }

            if (!file) return;

            const maxSize = 500 * 1024 * 1024; // 500MB
            if (file.size > maxSize) {
                alert(`Erro: O ficheiro é muito grande (${(file.size / 1024 / 1024).toFixed(1)}MB). O limite é 500MB.`);
                if (event) event.target.value = null;
                return;
            }

            try {
                const dataURL = await fileToDataURL(file);
                const resourceName = `skybox_${file.name}_${Date.now()}`;
                
                if (customSkyboxResourceName) {
                    loadedResources.delete(customSkyboxResourceName);
                }
                
                loadedResources.set(resourceName, dataURL);
                customSkyboxResourceName = resourceName;
                
                addCustomSkyboxOption(); 
                skyboxSelect.value = 'custom'; 
                loadSkybox('custom', dataURL); 
            } catch (err) {
                alert("Erro ao ler o ficheiro: " + err.message);
            }
            
            if (event) event.target.value = null;
        }

        function addCustomSkyboxOption() {
            let option = skyboxSelect.querySelector('option[value="custom"]');
            if (!option) {
                option = document.createElement('option');
                option.value = 'custom';
                option.textContent = 'Customizado';
                skyboxSelect.appendChild(option);
            }
        }
        
        function removeCustomSkyboxOption() {
            let option = skyboxSelect.querySelector('option[value="custom"]');
            if (option) {
                option.remove();
            }
            customSkyboxResourceName = null;
        }

        function fileToDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        }
        
        function requestResourceFile(promptMessage, acceptType, maxSize) {
            return new Promise((resolve, reject) => {
                alert(promptMessage);
                
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = acceptType;
                
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        reject(new Error("Nenhum ficheiro selecionado."));
                        return;
                    }
                    if (file.size > maxSize) {
                        reject(new Error(`Erro: O ficheiro é muito grande (${(file.size / 1024 / 1024).toFixed(1)}MB). O limite é ${(maxSize / 1024 / 1024).toFixed(0)}MB.`));
                        return;
                    }
                    try {
                        const dataURL = await fileToDataURL(file);
                        resolve(dataURL);
                    } catch(err) {
                        reject(err);
                    }
                };
                
                window.addEventListener('focus', () => {
                     setTimeout(() => {
                        if (!input.files || input.files.length === 0) {
                           // reject(new Error("Seleção de arquivo cancelada."));
                        }
                    }, 500);
                }, { once: true });
                
                input.click();
            });
        }

        // --- Funções de Seleção e Movimento (LÓGICA DE CLIQUE/ARRASTE) ---
        
        function onMouseDown(event) {
            if (event.button !== 0) return;
            if (transformControls.dragging) return;
            if (cameraMode === 'explore' && pointerLockControls && pointerLockControls.isLocked) return;
            
            isDragging = false;
            
            const intersect = getIntersectedObject(event.clientX, event.clientY);
            let intersectedObject = null;
            
            if (intersect) {
                intersectedObject = intersect.object;
                while (intersectedObject.parent && !draggableObjects.includes(intersectedObject)) {
                    intersectedObject = intersectedObject.parent;
                }
                // Como as luzes são invisíveis (material), getIntersectedObject NUNCA as encontrará.
                if (!draggableObjects.includes(intersectedObject)) {
                     intersectedObject = null;
                }
            }
            
            if (intersectedObject) {
                dragObject = intersectedObject;
                if (orbitControls) orbitControls.enabled = false;
            } else {
                dragObject = null;
            }

            clickTimer = setTimeout(() => {
                isDragging = true;
            }, clickThreshold);
        }
        
        function onMouseUp(event) {
            if (event.button !== 0) return;
            if (cameraMode === 'explore' && pointerLockControls && pointerLockControls.isLocked) return;
            
            clearTimeout(clickTimer);
            
            if (isDragging) {
                // Foi um arraste (drag)
            } else {
                // Foi um clique (click)
                if (!document.body.classList.contains('immersive-mode')) {
                    if (transformControls.dragging) return;
                    
                    if (dragObject) { // dragObject é o objeto clicável (não-luz)
                        setSelectedObject(dragObject);
                    } else {
                        // Clicou no chão, deseleciona tudo
                        setSelectedObject(null);
                    }
                }
            }
            
            isDragging = false;
            dragObject = null;
            if (orbitControls) orbitControls.enabled = true;
        }
        
        function onMouseMove(event) {
            if (isDragging && dragObject) { // dragObject NUNCA será uma luz
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                const intersects = raycaster.intersectObjects([...draggableObjects, groundPlane], true);
                
                let targetIntersect = null;
                
                for (const intersect of intersects) {
                    let parentObject = intersect.object;
                    while (parentObject.parent && !draggableObjects.includes(parentObject)) {
                        parentObject = parentObject.parent;
                    }
                    
                    if (parentObject !== dragObject) { 
                        targetIntersect = intersect;
                        break;
                    }
                }

                if (targetIntersect) {
                    const point = targetIntersect.point;
                    dragObject.position.x = point.x;
                    dragObject.position.z = point.z;
                    
                    if (targetIntersect.object.name === "ground") {
                        dragObject.position.y = getRequiredHeightForGround(dragObject);
                    } else {
                        let baseObject = targetIntersect.object;
                        while (baseObject.parent && !draggableObjects.includes(baseObject)) {
                            baseObject = baseObject.parent;
                        }
                        const topY = getObjectBaseHeight(baseObject, false); 
                        const objectBaseOffset = getRequiredHeightForGround(dragObject); 

                        dragObject.position.y = topY + objectBaseOffset;
                    }
                }
            }
        }

        // --- NOVO: Função de seleção atualizada ---
        function setSelectedObject(object) {
            if (selectedObject === object) return;
            
            selectedObject = object;

            if (selectedObject) {
                transformControls.attach(selectedObject);
                transformControls.setMode('translate');
                
                // Atualiza o dropdown
                if (selectedObject.userData.type === 'point_light') {
                    // Garante que o dropdown mostre o item certo
                    if (lightSelect.value !== selectedObject.uuid) {
                        lightSelect.value = selectedObject.uuid;
                    }
                } else {
                    // Se selecionamos um cubo, reseta o dropdown
                    lightSelect.value = 'none';
                }

            } else {
                transformControls.detach();
                lightSelect.value = 'none'; // Deseleciona no dropdown
            }
        }
        
        // --- NOVO: Função para atualizar o seletor de luz ---
        function updateLightSelector() {
            const selectedId = selectedObject ? selectedObject.uuid : null;
            
            while (lightSelect.options.length > 1) {
                lightSelect.remove(1);
            }

            let lightCount = 1;
            draggableObjects.forEach(obj => {
                if (obj.userData.type === 'point_light') {
                    if (!obj.userData.name) {
                        obj.userData.name = `Luz ${lightCount++}`;
                    }
                    const option = document.createElement('option');
                    option.value = obj.uuid;
                    option.textContent = obj.userData.name;
                    lightSelect.appendChild(option);
                }
            });

            if (selectedId && draggableObjects.some(o => o.uuid === selectedId && o.userData.type === 'point_light')) {
                lightSelect.value = selectedId;
            } else {
                lightSelect.value = 'none';
            }
        }
        
        // --- Lógica de Teclado Separada ---

        function onKeyUp(event) {
            switch (event.key) {
                case 'w': case 'W': 
                    moveForward = false;
                    break;
                case 'a': case 'A': 
                    moveLeft = false;
                    break;
                case 's': case 'S': 
                    moveBackward = false;
                    break;
                case 'd': case 'D': 
                    moveRight = false;
                    break;
                case ' ': // Espaço
                    moveUp = false;
                    break;
                case 'Shift':
                    moveDown = false;
                    break;
            }
        }

        function onKeyDown(event) {
            const targetNode = event.target.tagName.toLowerCase();
            if (targetNode === 'input' || targetNode === 'textarea' || targetNode === 'select') return; // Adicionado 'select'

            // --- ATALHOS GLOBAIS ---
            
            // Atalho 'H' para Modo Imersivo (Ocultar UI)
            if (event.key === 'h' || event.key === 'H') {
                document.body.classList.toggle('immersive-mode');
                
                // Se entramos no modo imersivo, deseleciona qualquer objeto para esconder o gizmo
                if (document.body.classList.contains('immersive-mode')) {
                    setSelectedObject(null);
                }
                
                event.preventDefault();
                return; // Sai da função
            }
            
            // Atalho 'C' para Mudar Modo de Câmera
            if (event.key === 'c' || event.key === 'C') {
                if (cameraMode === 'explore' && pointerLockControls && pointerLockControls.isLocked) {
                    // Não faz nada se estiver travado no modo FPS
                } else {
                    toggleCameraMode();
                }
                event.preventDefault();
                return; // Sai da função
            }

            // --- FIM DOS ATALHOS GLOBAIS ---


            if (cameraMode === 'explore' && pointerLockControls && pointerLockControls.isLocked) {
                switch (event.key) {
                    case 'w': case 'W':
                        moveForward = true;
                        break;
                    case 'a': case 'A':
                        moveLeft = true;
                        break;
                    case 's': case 'S':
                        moveBackward = true;
                        break;
                    case 'd': case 'D':
                        moveRight = true;
                        break;
                    case ' ': // Espaço
                        moveUp = true;
                        break;
                    case 'Shift':
                        moveDown = true;
                        break;
                }
                if (event.key !== 'Escape') {
                     event.preventDefault();
                }
                return; 
            }
            
            if (event.key === 'r' || event.key === 'R') {
                if (selectedObject && selectedObject.userData.type !== 'point_light') {
                    switch (transformControls.mode) {
                        case 'translate':
                            transformControls.setMode('rotate');
                            break;
                        case 'rotate':
                            transformControls.setMode('scale');
                            break;
                        case 'scale':
                            transformControls.setMode('translate');
                            break;
                    }
                    event.preventDefault();
                }
                // Permite rotação para luzes (para mudar a sombra)
                if (selectedObject && selectedObject.userData.type === 'point_light') {
                     switch (transformControls.mode) {
                        case 'translate':
                            transformControls.setMode('rotate');
                            break;
                        case 'rotate':
                             transformControls.setMode('translate');
                            break;
                    }
                    event.preventDefault();
                }
                return;
            }

            if (event.key === 'Delete' || event.key === 'Backspace') {
                if (selectedObject) {
                    deleteSelectedObject();
                    event.preventDefault();
                }
                return;
            }

            if (!selectedObject) return;
            if (selectedObject.userData.isGizmoDragging) return; 

            const moveIncrement = 0.25;
            let positionChanged = false;

            switch (event.key) {
                case 'ArrowUp':
                    selectedObject.position.z -= moveIncrement;
                    positionChanged = true;
                    break;
                case 'ArrowDown':
                    selectedObject.position.z += moveIncrement;
                    positionChanged = true;
                    break;
                case 'ArrowLeft':
                    selectedObject.position.x -= moveIncrement;
                    positionChanged = true;
                    break;
                case 'ArrowRight':
                    selectedObject.position.x += moveIncrement;
                    positionChanged = true;
                    break;
                case 'PageUp':
                    selectedObject.position.y += moveIncrement;
                    positionChanged = true;
                    break;
                case 'PageDown':
                    const minY = (selectedObject.userData.type === 'point_light') ? 0.1 : getRequiredHeightForGround(selectedObject);
                    const targetY = selectedObject.position.y - moveIncrement;
                    selectedObject.position.y = Math.max(minY, targetY);
                    positionChanged = true;
                    break;
                case 'Escape':
                    setSelectedObject(null);
                    break;
            }

            if (positionChanged) {
                event.preventDefault();
            }
        }

    </script>
</body>
</html>
